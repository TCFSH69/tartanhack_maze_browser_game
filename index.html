<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { margin:0; overflow:hidden; background:#000; color:#fff; font-family:sans-serif; touch-action:none; }
    canvas { display:block; }
    #ui { position:absolute; top:10px; left:10px; z-index:10; pointer-events:none; }
    #start-btn { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); padding:20px; font-size:20px; background:#0f0; color:#000; border:0; cursor:pointer; }
  </style>
</head>
<body>
  <div id="ui">Mic: <span id="mic-val">0</span></div>
  <button id="start-btn">Start (Allow Mic)</button>
  <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiMic = document.getElementById('mic-val');

let mapW=100, mapH=100, tile=20;
let map=[];
let player={x:1,y:1,dirX:0,dirY:1};

let audioContext, analyser, dataArray;
let micLevel=0;   // 0..10 display
let loud=0;       // 0..1 smoothed
let beamLen=0, beamLife=0;
const BEAM_LIFE_MAX=14;

// Colors
const FLOOR = "#2a2a2a";
const WALL  = "#6a6a6a";
const BEAM  = "#ffd400"; // yellow

function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
addEventListener('resize', resize); resize();

/* Map */
function genMap(){
  map=[];
  for(let y=0;y<mapH;y++){
    let r=[];
    for(let x=0;x<mapW;x++){
      r.push((x==0||y==0||x==mapW-1||y==mapH-1||Math.random()<0.2)?0:1);
    }
    map.push(r);
  }
  for(let yy=1;yy<=3;yy++) for(let xx=1;xx<=3;xx++) map[yy][xx]=1;
  player.x=1; player.y=1; player.dirX=0; player.dirY=1;
}

/* Audio */
async function initAudio(){
  const stream = await navigator.mediaDevices.getUserMedia({audio:true});
  audioContext = new (window.AudioContext||window.webkitAudioContext)();
  if(audioContext.state==="suspended") await audioContext.resume();
  analyser = audioContext.createAnalyser();
  analyser.fftSize=256;
  const src = audioContext.createMediaStreamSource(stream);
  src.connect(analyser);
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  document.getElementById('start-btn').style.display='none';
  loop();
}

function updateMic(){
  if(!analyser) return;

  analyser.getByteFrequencyData(dataArray);
  let sum=0;
  for(let i=0;i<dataArray.length;i++) sum += dataArray[i];
  const avg = sum / dataArray.length;

  micLevel = Math.min(10, (avg/10)|0);
  uiMic.textContent = micLevel;

  // smooth loudness 0..1
  const t = Math.min(1, avg/110); // sensitivity knob
  loud = t>loud ? (loud*0.80 + t*0.20) : (loud*0.93 + t*0.07);

  const desiredLen = Math.min(22, (loud*22)|0); // longer than before
  if(desiredLen>0){
    beamLen = desiredLen;
    beamLife = BEAM_LIFE_MAX;
  }else{
    if(beamLife>0) beamLife--;
    else beamLen=0;
  }
}

/* Movement */
function move(dx,dy){
  const nx=player.x+dx, ny=player.y+dy;
  if(map[ny]?.[nx]===1){ player.x=nx; player.y=ny; }
  if(dx||dy){ player.dirX=dx; player.dirY=dy; }
}
addEventListener('keydown', e=>{
  if(e.key==='w'||e.key==='ArrowUp') move(0,-1);
  if(e.key==='s'||e.key==='ArrowDown') move(0, 1);
  if(e.key==='a'||e.key==='ArrowLeft') move(-1,0);
  if(e.key==='d'||e.key==='ArrowRight') move(1,0);
});
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  const t=e.touches[0], cx=innerWidth/2, cy=innerHeight/2;
  const dx=t.clientX-cx, dy=t.clientY-cy;
  if(Math.abs(dx)>Math.abs(dy)) move(dx<0?-1:1,0);
  else move(0,dy<0?-1:1);
},{passive:false});

/* Draw */
function draw(){
  // full darkness
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const offX = canvas.width/2 - player.x*tile - tile/2;
  const offY = canvas.height/2 - player.y*tile - tile/2;

  // Smaller visible circle around player (in tiles)
  const R = 3.0;     // <-- smaller than before (was ~4.2)
  const pad = 14;    // draw window size

  const minX=Math.max(0, player.x-pad), maxX=Math.min(mapW-1, player.x+pad);
  const minY=Math.max(0, player.y-pad), maxY=Math.min(mapH-1, player.y+pad);

  // Build beam list (can extend beyond R)
  let beamList = null;
  if(beamLife>0 && beamLen>0 && (player.dirX||player.dirY)){
    beamList = [];
    for(let i=1;i<=beamLen;i++){
      const bx=player.x+player.dirX*i;
      const by=player.y+player.dirY*i;
      if(map[by]?.[bx]!==1) break; // stops at wall
      beamList.push([bx,by]);
    }
  }

  // Pass A: draw only the small circular region around player (unicolor tiles)
  for(let y=minY;y<=maxY;y++){
    for(let x=minX;x<=maxX;x++){
      const dx=x-player.x, dy=y-player.y;
      if(Math.sqrt(dx*dx+dy*dy) > R) continue;

      const px=x*tile+offX, py=y*tile+offY;
      ctx.fillStyle = map[y][x]===0 ? WALL : FLOOR;
      ctx.fillRect(px,py,tile,tile);
    }
  }

  // Pass B: draw beam tiles ANYWHERE (even outside the circle)
  if(beamList){
    for(const [x,y] of beamList){
      // draw underlying tile so itâ€™s visible even in darkness
      const px=x*tile+offX, py=y*tile+offY;
      ctx.fillStyle = map[y][x]===0 ? WALL : FLOOR;
      ctx.fillRect(px,py,tile,tile);

      // draw beam color on top
      ctx.fillStyle = BEAM;
      ctx.fillRect(px,py,tile,tile);
    }
  }

  // Player
  const pX=player.x*tile+offX, pY=player.y*tile+offY;
  ctx.fillStyle="#0f0";
  ctx.fillRect(pX,pY,tile,tile);

  // Facing dot
  ctx.fillStyle="#000";
  ctx.beginPath();
  ctx.arc(pX+tile/2+player.dirX*6, pY+tile/2+player.dirY*6, 2.2, 0, Math.PI*2);
  ctx.fill();

  // Glow overlay (visual glow only)
  const cx = pX + tile/2, cy = pY + tile/2;
  const glowR = tile * (1.9 + 0.9*loud); // slightly smaller glow than before
  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
  g.addColorStop(0.00, "rgba(255,255,255,0.33)");
  g.addColorStop(0.45, "rgba(255,255,255,0.10)");
  g.addColorStop(1.00, "rgba(255,255,255,0.00)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(cx, cy, glowR, 0, Math.PI*2);
  ctx.fill();
}

function loop(){
  updateMic();
  draw();
  requestAnimationFrame(loop);
}

document.getElementById('start-btn').addEventListener('click', ()=>{
  genMap();
  initAudio().catch(()=>alert("Microphone access denied! Must run on http://localhost"));
});
</script>
</body>
</html>
