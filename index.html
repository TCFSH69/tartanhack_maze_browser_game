<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; }
        #start-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; font-size: 20px; background: #0f0; color: #000; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ui">Mic Level: <span id="mic-val">0</span> | Steps: <span id="steps">0</span></div>
    <button id="start-btn">Start Game (Allow Mic)</button>
    <canvas id="gameCanvas"></canvas>

<script>
// --- 1. 初始化設定 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiMic = document.getElementById('mic-val');
let mapWidth = 100;
let mapHeight = 100;
let tileSize = 20;
let map = [];
let player = { x: 2, y: 2, dirX: 0, dirY: 1 };
let goal = { x: 0, y: 0 };
let micLevel = 0;
let audioContext, analyser, dataArray;

// 光束系統
let loud = 0;         // 平滑音量 0~1
let beamLen = 0;      // 光束長度 (格數)
let beamLife = 0;     // 光束殘留幀數
const BEAM_LIFE_MAX = 180; // ~3 秒 (60fps * 3)
const BEAM_COLOR = '#ffd400';
const FLOOR_COLOR = '#2a2a2a';
const WALL_COLOR = '#6a6a6a';
let fogCanvas, fogCtx;

// --- 2. 地圖生成 ---
function generateMap() {
    map = [];
    for (let y = 0; y < mapHeight; y++) {
        let row = [];
        for (let x = 0; x < mapWidth; x++) {
            if (x === 0 || x === mapWidth - 1 || y === 0 || y === mapHeight - 1 || Math.random() < 0.2) {
                row.push(0);
            } else {
                row.push(1);
            }
        }
        map.push(row);
    }
    // 確保起點周圍是空的
    for (let cy = 1; cy <= 3; cy++)
        for (let cx = 1; cx <= 3; cx++) map[cy][cx] = 1;
    player.x = 2; player.y = 2; player.dirX = 0; player.dirY = 1;

    // 生成終點
    while (true) {
        let gx = Math.floor(Math.random() * mapWidth);
        let gy = Math.floor(Math.random() * mapHeight);
        if (map[gy][gx] === 1 && (gx > 10 || gy > 10)) {
            goal = { x: gx, y: gy };
            break;
        }
    }
}

// --- 3. 麥克風與音訊處理 ---
async function initAudio() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') await audioContext.resume();
        analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        document.getElementById('start-btn').style.display = 'none';
        gameLoop();
    } catch (e) {
        alert("Microphone access denied! Game needs mic.");
    }
}

function updateMic() {
    if (!analyser) return;
    analyser.getByteFrequencyData(dataArray);

    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
    let avg = sum / dataArray.length;

    micLevel = Math.min(10, Math.floor(avg / 10));
    uiMic.innerText = micLevel;

    // 平滑音量 0~1
    let t = Math.min(1, avg / 110);
    loud = t > loud ? (loud * 0.80 + t * 0.20) : (loud * 0.93 + t * 0.07);

    // 光束長度與殘留
    let desiredLen = Math.min(22, (loud * 22) | 0);
    if (desiredLen > 0) {
        beamLen = desiredLen;
        beamLife = BEAM_LIFE_MAX;
    } else {
        if (beamLife > 0) beamLife--;
        else beamLen = 0;
    }
}

// 撞牆音效
function playWallHitSound() {
    if (!audioContext) return;
    let osc = audioContext.createOscillator();
    let gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, audioContext.currentTime);
    osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.15);
    gain.gain.setValueAtTime(0.3, audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
    osc.start(audioContext.currentTime);
    osc.stop(audioContext.currentTime + 0.15);
}

// --- 4. 遊戲邏輯與控制 ---
function move(dx, dy) {
    let newX = player.x + dx;
    let newY = player.y + dy;

    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight && map[newY][newX] === 1) {
        player.x = newX;
        player.y = newY;
    } else {
        playWallHitSound();
    }
    if (dx !== 0 || dy !== 0) {
        player.dirX = dx;
        player.dirY = dy;
    }

    if (player.x === goal.x && player.y === goal.y) {
        alert("You Win! Refresh to restart.");
        location.reload();
    }
}

// 鍵盤控制 (Desktop)
window.addEventListener('keydown', (e) => {
    if (['w','s','a','d','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    if (e.key === 'w' || e.key === 'ArrowUp') move(0, -1);
    if (e.key === 's' || e.key === 'ArrowDown') move(0, 1);
    if (e.key === 'a' || e.key === 'ArrowLeft') move(-1, 0);
    if (e.key === 'd' || e.key === 'ArrowRight') move(1, 0);
});

// 觸控控制 (Mobile)
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const cx = window.innerWidth / 2;
    const cy = window.innerHeight / 2;
    const dx = touch.clientX - cx;
    const dy = touch.clientY - cy;
    if (Math.abs(dx) > Math.abs(dy)) move(dx < 0 ? -1 : 1, 0);
    else move(0, dy < 0 ? -1 : 1);
}, { passive: false });

// --- 5. 渲染迴圈 ---
function draw() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let offX = (canvas.width / 2) - (player.x * tileSize) - (tileSize / 2);
    let offY = (canvas.height / 2) - (player.y * tileSize) - (tileSize / 2);

    // 繪製附近地圖格子（會被霧蓋住，靠光暈/光束才看得到）
    let pad = Math.max(beamLen + 2, 6);
    let minX = Math.max(0, player.x - pad), maxX = Math.min(mapWidth - 1, player.x + pad);
    let minY = Math.max(0, player.y - pad), maxY = Math.min(mapHeight - 1, player.y + pad);
    for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
            let px = x * tileSize + offX, py = y * tileSize + offY;
            ctx.fillStyle = map[y][x] === 0 ? WALL_COLOR : FLOOR_COLOR;
            ctx.fillRect(px, py, tileSize, tileSize);
        }
    }

    // 建立光束清單 (直線，碰牆停止)
    let beamTiles = null;
    if (beamLife > 0 && beamLen > 0 && (player.dirX || player.dirY)) {
        beamTiles = [];
        for (let i = 1; i <= beamLen; i++) {
            let bx = player.x + player.dirX * i;
            let by = player.y + player.dirY * i;
            if (map[by]?.[bx] !== 1) break;
            beamTiles.push([bx, by]);
        }
    }

    // 光束格子上色
    if (beamTiles) {
        for (const [x, y] of beamTiles) {
            let px = x * tileSize + offX, py = y * tileSize + offY;
            ctx.fillStyle = BEAM_COLOR;
            ctx.fillRect(px, py, tileSize, tileSize);
        }
    }

    // 繪製玩家
    let pX = player.x * tileSize + offX;
    let pY = player.y * tileSize + offY;
    ctx.fillStyle = '#0f0';
    ctx.fillRect(pX, pY, tileSize, tileSize);

    // 繪製方向指示
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(pX + tileSize / 2 + player.dirX * 6, pY + tileSize / 2 + player.dirY * 6, 2.2, 0, Math.PI * 2);
    ctx.fill();

    // 繪製終點
    let gX = goal.x * tileSize + offX;
    let gY = goal.y * tileSize + offY;
    ctx.fillStyle = 'gold';
    ctx.font = '16px Arial';
    ctx.fillText('\u{1F6A9}', gX, gY + 16);

    // --- Fog of War ---
    if (!fogCanvas) {
        fogCanvas = document.createElement('canvas');
        fogCtx = fogCanvas.getContext('2d');
    }
    fogCanvas.width = canvas.width;
    fogCanvas.height = canvas.height;
    fogCtx.globalCompositeOperation = 'source-over';
    fogCtx.fillStyle = '#000';
    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);

    fogCtx.globalCompositeOperation = 'destination-out';

    // 九宮格光暈（用漸層挖洞，讓底下地圖透出來）
    let cx = pX + tileSize / 2, cy = pY + tileSize / 2;
    let glowR = tileSize * 3;
    let g = fogCtx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
    g.addColorStop(0.00, 'rgba(0,0,0,1)');
    g.addColorStop(0.50, 'rgba(0,0,0,0.7)');
    g.addColorStop(1.00, 'rgba(0,0,0,0)');
    fogCtx.fillStyle = g;
    fogCtx.beginPath();
    fogCtx.arc(cx, cy, glowR, 0, Math.PI * 2);
    fogCtx.fill();

    // 光束挖洞（讓光束格子透出來）
    if (beamTiles) {
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
        for (const [x, y] of beamTiles) {
            fogCtx.fillRect(x * tileSize + offX, y * tileSize + offY, tileSize, tileSize);
        }
    }

    ctx.drawImage(fogCanvas, 0, 0);
}

function gameLoop() {
    updateMic();
    draw();
    requestAnimationFrame(gameLoop);
}

// 啟動按鈕
document.getElementById('start-btn').addEventListener('click', () => {
    generateMap();
    initAudio();
});

</script>
</body>
</html>
