<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; }
    canvas { display: block; image-rendering: pixelated; }

    /* UI ‰ªãÈù¢ */
    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none;
      text-shadow: 1px 1px 2px #000; font-weight: bold;
    }
    #effects-ui { margin-top: 6px; opacity: .9; font-size: 12px; font-weight: 700; }
    #objective-ui{
      margin-top: 6px;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .2px;
      opacity: .95;
    }
    .chk { opacity:.85; }
    .ok  { color: rgba(0,255,0,0.95); text-shadow: 0 0 12px rgba(0,255,0,0.2); }
    .no  { color: rgba(255,255,255,0.85); }

    /* Warning toast */
    #toast {
      position: absolute;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 40;
      background: rgba(0,0,0,0.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 10px 14px;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.55), 0 0 18px rgba(255,200,0,0.18);
      font-weight: 900;
      font-size: 13px;
      letter-spacing: .2px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 180ms ease, transform 180ms ease;
    }
    #toast.show { opacity: 1; transform: translateX(-50%) translateY(6px); }
    #toast .sub { display:block; font-weight: 800; opacity: .85; font-size: 12px; margin-top: 3px; }

    /* START button */
    #start-btn {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      padding: 20px 40px; font-size: 24px; font-weight: 900;
      background: #0f0; color: #000; border: 3px solid #fff; cursor: pointer; border-radius: 14px;
      box-shadow: 0 0 18px rgba(0,255,0,0.85), 0 12px 30px rgba(0,0,0,0.65);
      z-index: 20;
    }

    #controls-hint {
      position: absolute; bottom: 10px; width: 100%; text-align: center;
      color: #888; font-size: 12px; pointer-events: none;
    }

    #flash-btn {
      position: absolute; top: 10px; right: 10px; z-index: 20;
      padding: 10px 18px; font-size: 14px; font-weight: bold;
      background: #fff; color: #000; border: 2px solid #ffd700; cursor: pointer;
      border-radius: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    #flash-btn:disabled { opacity: 0.3; cursor: default; }

    #flash-overlay {
      display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 25; align-items: center; justify-content: center;
      flex-direction: column; background: #fff;
      opacity: 1; transition: opacity 2s ease, background 1.2s ease;
    }
    #flash-overlay.fade-out { opacity: 0; }
    #flash-overlay img {
      max-width: 70%; max-height: 50%; object-fit: contain;
      opacity: 0; transition: opacity 1.2s ease;
      filter: drop-shadow(0 0 40px rgba(255,255,255,0.8));
    }
    #flash-overlay.show-ad { background: rgba(0,0,0,0.9); }
    #flash-overlay.show-ad img { opacity: 1; }

    /* End screens */
    .end-screen {
      display: none;
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 30;
      align-items: center; justify-content: center; text-align: center;
      flex-direction: column;
    }
    .end-screen h1 { font-size: 60px; margin: 0; letter-spacing: 5px; }
    .end-screen p { font-size: 20px; margin: 5px 0; }
    #win h1 { color: #ffd700; text-shadow: 0 0 20px #ffd700; }
    #lose h1 { color: #ff0000; text-shadow: 0 0 20px #ff0000; }

    /* =========================
       Tutorial Panels (Start)
       ========================= */
    .start-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 340px;
      padding: 16px 18px;
      border-radius: 18px;

      background: rgba(10, 14, 18, 0.78);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);

      color: rgba(255,255,255,0.92);
      box-shadow: 0 0 18px rgba(0,255,0,0.18), 0 10px 30px rgba(0,0,0,0.55);

      pointer-events: none;
      user-select: none;
      z-index: 19; /* below start button */
      opacity: 0;
      transform-origin: center;
      animation: panelIn 700ms ease forwards;
    }
    @keyframes panelIn { from { opacity: 0; filter: blur(2px); } to { opacity: 1; filter: blur(0); } }

    .start-panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: rgba(0,255,0,0.95);
      text-shadow: 0 0 10px rgba(0,255,0,0.25);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .start-panel ul { margin: 0; padding-left: 18px; line-height: 1.55; font-size: 13px; color: rgba(255,255,255,0.90); }
    .start-panel li { margin: 6px 0; }

    .kbd {
      display: inline-block;
      padding: 2px 7px;
      margin: 0 2px;
      border-radius: 9px;
      background: rgba(255,255,255,0.12);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.14);
      font-weight: 800;
      font-size: 12px;
      letter-spacing: 0.5px;
    }

    .pulse-hint {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, calc(-50% + 95px));
      z-index: 19;
      pointer-events: none;
      user-select: none;
      font-size: 13px;
      color: rgba(255,255,255,0.75);
      text-shadow: 0 0 12px rgba(0,0,0,0.8);
      animation: pulse 1.2s ease-in-out infinite;
    }
    @keyframes pulse { 0%, 100% { opacity: 0.55; } 50% { opacity: 1; } }

    /* Positions (desktop) */
    #panel-top    { transform: translate(-50%, calc(-50% - 230px)); }
    #panel-left   { transform: translate(calc(-50% - 450px), -50%); }
    #panel-right  { transform: translate(calc(-50% + 450px), -50%); }
    #panel-bottom { transform: translate(-50%, calc(-50% + 210px)); width: 520px; }

    /* Responsive stacking */
    @media (max-width: 980px) {
      .start-panel { width: 300px; }
      #panel-top    { transform: translate(-50%, calc(-50% - 240px)); }
      #panel-left   { transform: translate(-50%, calc(-50% + 200px)); }
      #panel-right  { transform: translate(-50%, calc(-50% + 355px)); }
      #panel-bottom { transform: translate(-50%, calc(-50% + 510px)); width: 300px; }
      .pulse-hint   { transform: translate(-50%, calc(-50% + 110px)); }
    }
  </style>
</head>

<body>
  <div id="toast">
    ‚ö†Ô∏è You can't escape yet!
    <span class="sub">Find at least one üåÄ and one üîÄ first.</span>
  </div>

  <div id="ui">
    Mic Level: <span id="mic-val">0</span> <br>
    Ghosts: <span id="ghost-count">5</span>
    <div id="effects-ui"></div>
    <div id="objective-ui"></div>
  </div>

  <!-- Tutorials / Controls panels -->
  <div id="panel-top" class="start-panel">
    <h3>üéØ Objective</h3>
    <ul>
      <li>Collect at least <b>one</b> üåÄ <b>and</b> <b>one</b> üîÄ.</li>
      <li>Then touch the <span class="kbd">üèÅ</span> flag to <b>escape</b>.</li>
      <li>Avoid ghosts üëª ‚Äî touching one = üíÄ</li>
    </ul>
  </div>

  <div id="panel-left" class="start-panel">
    <h3>üïπÔ∏è Movement</h3>
    <ul>
      <li>Keyboard: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span></li>
      <li>Mobile: left joystick to move üëà</li>
    </ul>
  </div>

  <div id="panel-right" class="start-panel">
    <h3>üéÆ Aim & Shoot</h3>
    <ul>
      <li>Mouse: aim direction üñ±Ô∏è</li>
      <li>Mobile: right joystick to aim üëâ</li>
      <li><b>Scream</b> to shoot üé§ (mic loudness)</li>
    </ul>
  </div>

  <div id="panel-bottom" class="start-panel">
    <h3>üí• Tools & Powerups</h3>
    <ul>
      <li><span class="kbd">Flash Grenade</span> (one-time): reveals the whole map briefly ‚ú®</li>
      <li>üîÄ <b>Invert</b> (10s): movement flips (W‚ÜîS, A‚ÜîD). Shooting unaffected.</li>
      <li>üåÄ <b>Wobble</b> (10s): camera shakes/wobbles.</li>
      <li>üõ°Ô∏è <b>Invincible</b> (5s): ghosts can‚Äôt kill you.</li>
    </ul>
  </div>

  <div id="start-hint" class="pulse-hint">‚ú® Click <b>START ESCAPE</b> to begin</div>

  <button id="start-btn">START ESCAPE</button>
  <div id="controls-hint">WASD to Move | Mouse to Aim | Scream to Shoot</div>

  <button id="flash-btn">Flash Grenade</button>
  <canvas id="gameCanvas"></canvas>

  <div id="flash-overlay">
    <img src="27e3d95f-7921-4231-9fad-420a3afd34d2_1251x779.webp" alt="AppLovin">
  </div>

  <div id="win" class="end-screen">
    <div>
      <h1>ESCAPED</h1>
      <p>You found the goal.</p>
      <p style="opacity:.7;margin-top:15px; font-size: 14px;">(Click anywhere to restart)</p>
    </div>
  </div>

  <div id="lose" class="end-screen">
    <div>
      <h1>YOU DIED</h1>
      <p>You have been caught.</p>
      <p style="opacity:.7;margin-top:15px; font-size: 14px;">(Click anywhere to restart)</p>
    </div>
  </div>

<script>
/* ==========================
   ‚òÖ Global Constants ‚òÖ
   ========================== */
const MAP_WIDTH = 31;
const MAP_HEIGHT = 31;
const TILE_SIZE = 20;

const FLOOR_COLOR = '#222';
const WALL_COLOR = '#555';

// player + ghosts
const PLAYER_MOVE_DELAY = 10;
const GHOST_COUNT = 5;
const GHOST_SPEED = 0.25;
const GHOST_RESPAWN_TIME = 300;

// combat
const BULLET_SPEED = 4;
const FIRE_THRESHOLD = 10;
const FIRE_COOLDOWN = 400;

// Pixel mode (from v2)
const PIXEL_SCALE = 3; // 1=normal, 2~4=more pixelated

// ===== Powerups =====
const POWERUP_COUNTS = { invert: 2, wobble: 2, invincible: 1 };
const POWERUP_TYPES = {
  invert:     { emoji: 'üîÄ', durationMs: 10000 },
  wobble:     { emoji: 'üåÄ', durationMs: 10000 },
  invincible: { emoji: 'üõ°Ô∏è', durationMs: 5000  }
};
/* ========================== */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const uiMic = document.getElementById('mic-val');
const uiGhostCount = document.getElementById('ghost-count');
const effectsUI = document.getElementById('effects-ui');
const objectiveUI = document.getElementById('objective-ui');
const toast = document.getElementById('toast');

const startBtn = document.getElementById('start-btn');
const winScreen = document.getElementById('win');
const loseScreen = document.getElementById('lose');

const panelTop = document.getElementById('panel-top');
const panelLeft = document.getElementById('panel-left');
const panelRight = document.getElementById('panel-right');
const panelBottom = document.getElementById('panel-bottom');
const startHint = document.getElementById('start-hint');

function setTutorialVisible(v) {
  const d = v ? 'block' : 'none';
  panelTop.style.display = d;
  panelLeft.style.display = d;
  panelRight.style.display = d;
  panelBottom.style.display = d;
  startHint.style.display = d;
}
setTutorialVisible(true);

// Optional sprites (from v2) with fallback (from v1)
const playerImg = new Image();
playerImg.src = 'player.jpg';
let playerImgReady = false;
playerImg.onload = () => { playerImgReady = true; };

const ghostImg = new Image();
ghostImg.src = 'ghost.jpg';
let ghostImgReady = false;
ghostImg.onload = () => { ghostImgReady = true; };

let map = [];
let player = { x: 1, y: 1, dirX: 0, dirY: 1, aimDirX: 0, aimDirY: 1, moveTimer: 0 };
let goal = { x: 0, y: 0 };
let bullets = [];
let lastFireTime = 0;
let ghosts = [];
let fogCanvas, fogCtx;

let flashActive = false;
let flashUsed = false;

let audioContext, analyser, dataArray;
let micLevel = 0;
let gameActive = false;

let activeKeys = [];
let leftTouchId = null;
let leftStick = { startX: 0, startY: 0, currX: 0, currY: 0, active: false };
let rightTouchId = null;
let rightStick = { startX: 0, startY: 0, currX: 0, currY: 0, active: false };
let mousePos = { x: 0, y: 0 };

// Powerup state
let powerups = []; // {x,y,type,emoji}
let effects = { invertUntil: 0, wobbleUntil: 0, invincibleUntil: 0 };

// Objective progress
let objective = { gotInvert: false, gotWobble: false };

// Toast
let toastTimer = null;
function showToast(msgMain, msgSub) {
  toast.innerHTML = `${msgMain}<span class="sub">${msgSub}</span>`;
  toast.classList.add('show');
  if (toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(() => toast.classList.remove('show'), 1800);
}

// UI updaters
function updateEffectsUI() {
  const now = Date.now();
  const items = [];
  if (now < effects.invertUntil) items.push(`üîÄ Invert: ${Math.ceil((effects.invertUntil-now)/1000)}s`);
  if (now < effects.wobbleUntil) items.push(`üåÄ Wobble: ${Math.ceil((effects.wobbleUntil-now)/1000)}s`);
  if (now < effects.invincibleUntil) items.push(`üõ°Ô∏è Invincible: ${Math.ceil((effects.invincibleUntil-now)/1000)}s`);
  effectsUI.innerText = items.length ? items.join(' | ') : '';
}
function updateObjectiveUI() {
  const i = objective.gotInvert;
  const w = objective.gotWobble;
  objectiveUI.innerHTML =
    `Objective: ` +
    `<span class="chk ${w ? 'ok' : 'no'}">üåÄ ${w ? 'OK' : '0/1'}</span>  ` +
    `<span class="chk ${i ? 'ok' : 'no'}">üîÄ ${i ? 'OK' : '0/1'}</span>  ` +
    `‚Üí <span class="chk ${w && i ? 'ok' : 'no'}">üèÅ Escape</span>`;
}

/* ==========================
   Powerup helpers
   ========================== */
function isWalkableCell(x, y) {
  return x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT && map[y][x] === 1;
}
function cellOccupiedByPowerup(x, y) {
  return powerups.some(p => p.x === x && p.y === y);
}
function spawnPowerups() {
  powerups = [];
  const avoidNear = [{ x: player.x, y: player.y }, { x: goal.x, y: goal.y }];

  function tooClose(rx, ry) {
    return avoidNear.some(pt => Math.abs(rx - pt.x) + Math.abs(ry - pt.y) < 6);
  }

  function placeType(type, count) {
    let placed = 0, attempts = 0;
    while (placed < count && attempts < 5000) {
      attempts++;
      const rx = Math.floor(Math.random() * MAP_WIDTH);
      const ry = Math.floor(Math.random() * MAP_HEIGHT);
      if (!isWalkableCell(rx, ry)) continue;
      if (cellOccupiedByPowerup(rx, ry)) continue;
      if (tooClose(rx, ry)) continue;
      powerups.push({ x: rx, y: ry, type, emoji: POWERUP_TYPES[type].emoji });
      placed++;
    }
  }

  placeType('invert', POWERUP_COUNTS.invert);
  placeType('wobble', POWERUP_COUNTS.wobble);
  placeType('invincible', POWERUP_COUNTS.invincible);
}

function activatePowerup(type) {
  const now = Date.now();
  const dur = POWERUP_TYPES[type].durationMs;

  if (type === 'invert') { effects.invertUntil = Math.max(effects.invertUntil, now + dur); objective.gotInvert = true; }
  if (type === 'wobble') { effects.wobbleUntil = Math.max(effects.wobbleUntil, now + dur); objective.gotWobble = true; }
  if (type === 'invincible') { effects.invincibleUntil = Math.max(effects.invincibleUntil, now + dur); }

  updateObjectiveUI();
}

function checkPowerupPickup() {
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    if (p.x === player.x && p.y === player.y) {
      activatePowerup(p.type);
      powerups.splice(i, 1);
    }
  }
}

function canEscapeNow() { return objective.gotInvert && objective.gotWobble; }

/* ==========================
   Maze generation
   ========================== */
function generateMaze() {
  map = [];
  for (let y = 0; y < MAP_HEIGHT; y++) {
    let row = [];
    for (let x = 0; x < MAP_WIDTH; x++) row.push(0);
    map.push(row);
  }

  let stack = [];
  let startX = 1, startY = 1;
  map[startY][startX] = 1;
  stack.push({x: startX, y: startY});

  while (stack.length > 0) {
    let current = stack[stack.length - 1];
    let neighbors = [];
    let directions = [{dx: 0, dy: -2}, {dx: 0, dy: 2}, {dx: -2, dy: 0}, {dx: 2, dy: 0}];

    for (let dir of directions) {
      let nx = current.x + dir.dx;
      let ny = current.y + dir.dy;
      if (nx > 0 && nx < MAP_WIDTH - 1 && ny > 0 && ny < MAP_HEIGHT - 1 && map[ny][nx] === 0) {
        neighbors.push({x: nx, y: ny, dx: dir.dx, dy: dir.dy});
      }
    }

    if (neighbors.length > 0) {
      let next = neighbors[Math.floor(Math.random() * neighbors.length)];
      map[current.y + next.dy / 2][current.x + next.dx / 2] = 1;
      map[next.y][next.x] = 1;
      stack.push({x: next.x, y: next.y});
    } else {
      stack.pop();
    }
  }

  // add loops
  for (let y = 1; y < MAP_HEIGHT - 1; y++) {
    for (let x = 1; x < MAP_WIDTH - 1; x++) {
      if (map[y][x] === 0 && Math.random() < 0.05) {
        let n = 0;
        if (map[y-1][x] === 1) n++;
        if (map[y+1][x] === 1) n++;
        if (map[y][x-1] === 1) n++;
        if (map[y][x+1] === 1) n++;
        if (n >= 2) map[y][x] = 1;
      }
    }
  }

  // reset player
  player.x = 1; player.y = 1;
  player.dirX = 0; player.dirY = 1;
  player.aimDirX = 0; player.aimDirY = 1;
  player.moveTimer = 0;

  // reset effects + objective
  effects.invertUntil = 0;
  effects.wobbleUntil = 0;
  effects.invincibleUntil = 0;

  objective.gotInvert = false;
  objective.gotWobble = false;
  updateObjectiveUI();

  // farthest goal
  let maxDist = 0;
  for (let y = 0; y < MAP_HEIGHT; y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
      if (map[y][x] === 1) {
        let dist = Math.abs(x - player.x) + Math.abs(y - player.y);
        if (dist > maxDist) { maxDist = dist; goal = {x, y}; }
      }
    }
  }

  // ghosts
  ghosts = [];
  for (let i = 0; i < GHOST_COUNT; i++) {
    let placed = false;
    while (!placed) {
      let rx = Math.floor(Math.random() * MAP_WIDTH);
      let ry = Math.floor(Math.random() * MAP_HEIGHT);
      if (map[ry][rx] === 1 && (Math.abs(rx - player.x) + Math.abs(ry - player.y) > 10)) {
        ghosts.push(new Ghost(rx, ry));
        placed = true;
      }
    }
  }

  // powerups
  spawnPowerups();

  uiGhostCount.innerText = ghosts.length;
  uiGhostCount.style.color = "white";

  startBtn.style.display = 'none';
  setTutorialVisible(false);
  winScreen.style.display = 'none';
  loseScreen.style.display = 'none';

  gameActive = true;
}

/* ==========================
   Ghost class
   ========================== */
class Ghost {
  constructor(startX, startY) {
    this.x = startX * TILE_SIZE;
    this.y = startY * TILE_SIZE;
    this.size = 18;
    this.color = 'red';
    this.speed = GHOST_SPEED;
    this.targetX = this.x;
    this.targetY = this.y;
    this.isDead = false;
    this.respawnTimer = 0;
  }

  update(player, map) {
    if (this.isDead) {
      this.respawnTimer--;
      if (this.respawnTimer <= 0) this.respawn(player, map);
      return;
    }

    let dist = Math.abs(this.x - this.targetX) + Math.abs(this.y - this.targetY);
    if (dist < this.speed) {
      this.x = this.targetX;
      this.y = this.targetY;
      let gx = Math.round(this.x / TILE_SIZE);
      let gy = Math.round(this.y / TILE_SIZE);
      let next = this.bfs(gx, gy, player.x, player.y, map);
      if (next) {
        this.targetX = next.x * TILE_SIZE;
        this.targetY = next.y * TILE_SIZE;
      }
    }

    if (this.x < this.targetX) this.x += this.speed;
    if (this.x > this.targetX) this.x -= this.speed;
    if (this.y < this.targetY) this.y += this.speed;
    if (this.y > this.targetY) this.y -= this.speed;
  }

  respawn(player, map) {
    let attempts = 100;
    while (attempts-- > 0) {
      let rx = Math.floor(Math.random() * MAP_WIDTH);
      let ry = Math.floor(Math.random() * MAP_HEIGHT);
      if (map[ry][rx] === 1 && Math.abs(rx - player.x) + Math.abs(ry - player.y) > 15) {
        this.x = rx * TILE_SIZE;
        this.y = ry * TILE_SIZE;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isDead = false;
        break;
      }
    }
  }

  bfs(sx, sy, ex, ey, map) {
    if (sx === ex && sy === ey) return null;
    let queue = [{x: sx, y: sy}];
    let from = {};
    let sk = `${sx},${sy}`;
    from[sk] = null;
    let found = false;
    let iterations = 0;

    while (queue.length > 0 && iterations < 500) {
      iterations++;
      let c = queue.shift();
      if (c.x === ex && c.y === ey) { found = true; break; }
      for (let [dx, dy] of [[0,-1],[0,1],[-1,0],[1,0]]) {
        let nx = c.x + dx, ny = c.y + dy, k = `${nx},${ny}`;
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT &&
            map[ny][nx] === 1 && !from.hasOwnProperty(k)) {
          queue.push({x: nx, y: ny});
          from[k] = {x: c.x, y: c.y};
        }
      }
    }
    if (!found) return null;

    let ck = `${ex},${ey}`, path = [];
    if (!from[ck]) return null;
    while (ck !== sk) {
      let p = ck.split(',').map(Number);
      path.push({x: p[0], y: p[1]});
      let pr = from[ck];
      ck = `${pr.x},${pr.y}`;
    }
    return path[path.length - 1];
  }

  checkCollision(player) {
    if (this.isDead) return false;
    let px = player.x * TILE_SIZE, py = player.y * TILE_SIZE;
    return this.x < px + TILE_SIZE - 4 && this.x + this.size > px + 4 &&
           this.y < py + TILE_SIZE - 4 && this.y + this.size > py + 4;
  }

  draw(ctx, offX, offY) {
    if (this.isDead) return;
    let sx = this.x + offX, sy = this.y + offY;

    if (ghostImgReady) {
      ctx.drawImage(ghostImg, sx, sy, this.size, this.size);
      return;
    }

    // fallback (v1 style)
    ctx.fillStyle = this.color;
    ctx.fillRect(sx, sy, this.size, this.size);
    let ex = this.targetX > this.x ? 2 : this.targetX < this.x ? -2 : 0;
    let ey = this.targetY > this.y ? 2 : this.targetY < this.y ? -2 : 0;
    ctx.fillStyle = 'white';
    ctx.fillRect(sx + 4 + ex, sy + 4 + ey, 5, 5);
    ctx.fillRect(sx + 10 + ex, sy + 4 + ey, 5, 5);
  }
}

/* ==========================
   Audio + Mic
   ========================== */
async function initAudio() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    generateMaze();
    playSong();
    gameLoop();
  } catch (e) {
    alert("Microphone denied! Please allow access.");
  }
}

function updateMic() {
  if (!analyser) return;
  analyser.getByteFrequencyData(dataArray);
  let sum = 0;
  for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
  let avg = sum / dataArray.length;

  micLevel = Math.min(10, Math.floor(avg / 10));
  uiMic.innerText = micLevel + ` (dB: ${Math.floor(avg)})`;

  if (gameActive && avg > FIRE_THRESHOLD && Date.now() - lastFireTime > FIRE_COOLDOWN) {
    fireBullet();
    lastFireTime = Date.now();
  }
}

/* ==========================
   Combat
   ========================== */
function fireBullet() {
  bullets.push({
    x: player.x * TILE_SIZE + TILE_SIZE / 2,
    y: player.y * TILE_SIZE + TILE_SIZE / 2,
    vx: player.aimDirX * BULLET_SPEED,
    vy: player.aimDirY * BULLET_SPEED
  });
}

function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;

    let gx = Math.floor(b.x / TILE_SIZE);
    let gy = Math.floor(b.y / TILE_SIZE);

    if (gx < 0 || gx >= MAP_WIDTH || gy < 0 || gy >= MAP_HEIGHT || map[gy][gx] === 0) {
      bullets.splice(i, 1);
      continue;
    }

    for (let g of ghosts) {
      if (!g.isDead) {
        if (b.x > g.x && b.x < g.x + g.size && b.y > g.y && b.y < g.y + g.size) {
          g.isDead = true;
          g.respawnTimer = GHOST_RESPAWN_TIME;
          bullets.splice(i, 1);
          break;
        }
      }
    }
  }
}

/* ==========================
   Input
   ========================== */
function updateAim() {
  if (rightStick.active) {
    let dx = rightStick.currX - rightStick.startX;
    let dy = rightStick.currY - rightStick.startY;
    if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
      if (Math.abs(dx) > Math.abs(dy)) { player.aimDirX = dx > 0 ? 1 : -1; player.aimDirY = 0; }
      else { player.aimDirX = 0; player.aimDirY = dy > 0 ? 1 : -1; }
    }
  } else {
    let cx = window.innerWidth / 2, cy = window.innerHeight / 2;
    let dx = mousePos.x - cx, dy = mousePos.y - cy;
    if (dx !== 0 || dy !== 0) {
      if (Math.abs(dx) > Math.abs(dy)) { player.aimDirX = dx > 0 ? 1 : -1; player.aimDirY = 0; }
      else { player.aimDirX = 0; player.aimDirY = dy > 0 ? 1 : -1; }
    }
  }
}

function updatePlayerMovement() {
  if (player.moveTimer > 0) { player.moveTimer--; return; }

  let dx = 0, dy = 0;

  if (leftStick.active) {
    let touchDx = leftStick.currX - leftStick.startX;
    let touchDy = leftStick.currY - leftStick.startY;
    if (Math.abs(touchDx) > 20 || Math.abs(touchDy) > 20) {
      if (Math.abs(touchDx) > Math.abs(touchDy)) dx = touchDx > 0 ? 1 : -1;
      else dy = touchDy > 0 ? 1 : -1;
    }
  } else if (activeKeys.length > 0) {
    const lastKey = activeKeys[activeKeys.length - 1];
    if (lastKey === 'w' || lastKey === 'ArrowUp') dy = -1;
    else if (lastKey === 's' || lastKey === 'ArrowDown') dy = 1;
    else if (lastKey === 'a' || lastKey === 'ArrowLeft') dx = -1;
    else if (lastKey === 'd' || lastKey === 'ArrowRight') dx = 1;
  }

  // üîÄ invert movement effect (movement only)
  const now = Date.now();
  if (now < effects.invertUntil) { dx *= -1; dy *= -1; }

  if (dx !== 0 || dy !== 0) {
    player.dirX = dx; player.dirY = dy;
    let newX = player.x + dx;
    let newY = player.y + dy;

    if (newX >= 0 && newX < MAP_WIDTH && newY >= 0 && newY < MAP_HEIGHT && map[newY][newX] === 1) {
      player.x = newX;
      player.y = newY;
      player.moveTimer = PLAYER_MOVE_DELAY;

      // pickup powerups
      checkPowerupPickup();

      // dead-end detection
      let walls = 0;
      if (map[player.y - 1]?.[player.x] === 0) walls++;
      if (map[player.y + 1]?.[player.x] === 0) walls++;
      if (map[player.y]?.[player.x - 1] === 0) walls++;
      if (map[player.y]?.[player.x + 1] === 0) walls++;
      if (walls >= 3) playGobackSound();

      // goal touch: objective gating
      if (player.x === goal.x && player.y === goal.y) {
        if (canEscapeNow()) {
          gameOver('win');
        } else {
          const needW = objective.gotWobble ? '' : 'üåÄ';
          const needI = objective.gotInvert ? '' : 'üîÄ';
          showToast('‚ö†Ô∏è You can‚Äôt escape yet!', `Find ${needW}${needW && needI ? ' and ' : ''}${needI} first.`);
        }
      }
    }
  }
}

/* ==========================
   Rendering (pixel + flash zoom + effects)
   ========================== */
function draw() {
  // pixel canvas sizing (from v2)
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  canvas.width = Math.max(1, Math.floor(window.innerWidth / PIXEL_SCALE));
  canvas.height = Math.max(1, Math.floor(window.innerHeight / PIXEL_SCALE));
  ctx.imageSmoothingEnabled = false;

  const now = Date.now();

  // flash zoom: show whole map on screen (from v2)
  let flashZoom = 1;
  if (flashActive) {
    let mapW = MAP_WIDTH * TILE_SIZE;
    let mapH = MAP_HEIGHT * TILE_SIZE;
    flashZoom = Math.min(canvas.width / mapW, canvas.height / mapH) * 0.9;
  }

  let offX, offY;
  if (flashActive) {
    offX = (canvas.width / 2) - (MAP_WIDTH * TILE_SIZE * flashZoom / 2);
    offY = (canvas.height / 2) - (MAP_HEIGHT * TILE_SIZE * flashZoom / 2);
    ctx.save();
    ctx.translate(offX, offY);
    ctx.scale(flashZoom, flashZoom);
    offX = 0; offY = 0;
  } else {
    offX = (canvas.width / 2) - (player.x * TILE_SIZE) - (TILE_SIZE / 2);
    offY = (canvas.height / 2) - (player.y * TILE_SIZE) - (TILE_SIZE / 2);

    // üåÄ wobble effect (camera shift)
    if (now < effects.wobbleUntil) {
      const t = now * 0.015;
      offX += Math.sin(t) * 8;
      offY += Math.cos(t * 1.3) * 8;
    }
  }

  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // map draw range
  let startCol, startRow, endCol, endRow;
  if (flashActive) {
    startCol = 0; startRow = 0;
    endCol = MAP_WIDTH - 1; endRow = MAP_HEIGHT - 1;
  } else {
    let cols = Math.ceil(canvas.width / TILE_SIZE);
    let rows = Math.ceil(canvas.height / TILE_SIZE);
    startCol = Math.floor(-offX / TILE_SIZE);
    startRow = Math.floor(-offY / TILE_SIZE);
    endCol = startCol + cols;
    endRow = startRow + rows;
  }

  for (let y = startRow; y <= endRow; y++) {
    for (let x = startCol; x <= endCol; x++) {
      if (y >= 0 && y < MAP_HEIGHT && x >= 0 && x < MAP_WIDTH) {
        let px = x * TILE_SIZE + offX;
        let py = y * TILE_SIZE + offY;
        ctx.fillStyle = map[y][x] === 0 ? WALL_COLOR : FLOOR_COLOR;
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
      }
    }
  }

  // powerups
  ctx.save();
  ctx.font = `${Math.max(8, Math.floor(18))}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  for (const p of powerups) {
    const px = p.x * TILE_SIZE + offX + TILE_SIZE / 2;
    const py = p.y * TILE_SIZE + offY + TILE_SIZE / 2;
    ctx.shadowColor = 'rgba(255,255,255,0.35)';
    ctx.shadowBlur = 10;
    ctx.fillText(p.emoji, px, py);
  }
  ctx.restore();

  // bullets
  ctx.fillStyle = '#ffff00';
  for (let b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x + offX, b.y + offY, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  // player
  let pX = player.x * TILE_SIZE + offX;
  let pY = player.y * TILE_SIZE + offY;

  // üõ°Ô∏è invincible glow (tile outline)
  const invincible = now < effects.invincibleUntil;
  if (invincible) {
    ctx.save();
    ctx.strokeStyle = 'rgba(0,255,255,0.9)';
    ctx.lineWidth = 3;
    ctx.shadowColor = 'rgba(0,255,255,0.8)';
    ctx.shadowBlur = 18;
    ctx.strokeRect(pX - 3, pY - 3, TILE_SIZE + 6, TILE_SIZE + 6);
    ctx.restore();
  }

  if (playerImgReady) {
    ctx.drawImage(playerImg, pX, pY, TILE_SIZE, TILE_SIZE);
  } else {
    ctx.fillStyle = '#0f0';
    ctx.fillRect(pX, pY, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(pX + TILE_SIZE/2 + player.dirX*6, pY + TILE_SIZE/2 + player.dirY*6, 2.2, 0, Math.PI*2);
    ctx.fill();
  }

  // aim reticle
  let pcx = pX + TILE_SIZE / 2;
  let pcy = pY + TILE_SIZE / 2;
  let reticleDist = 40;
  let reticleX = pcx + player.aimDirX * reticleDist;
  let reticleY = pcy + player.aimDirY * reticleDist;

  ctx.save();
  ctx.strokeStyle = '#ff0000';
  ctx.lineWidth = 3;
  ctx.shadowColor = '#ff0000';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(reticleX, reticleY, 10, 0, Math.PI * 2);
  ctx.moveTo(reticleX - 14, reticleY); ctx.lineTo(reticleX + 14, reticleY);
  ctx.moveTo(reticleX, reticleY - 14); ctx.lineTo(reticleX, reticleY + 14);
  ctx.stroke();
  ctx.restore();

  // ghosts
  let aliveCount = 0;
  for (let g of ghosts) {
    g.draw(ctx, offX, offY);
    if (!g.isDead) aliveCount++;
  }
  uiGhostCount.innerText = aliveCount;

  // goal
  let gX = goal.x * TILE_SIZE + offX;
  let gY = goal.y * TILE_SIZE + offY;
  ctx.fillStyle = 'gold';
  ctx.font = '16px Arial';
  ctx.fillText('\u{1F6A9}', gX, gY + 16);

  let cx = pX + TILE_SIZE / 2, cy = pY + TILE_SIZE / 2;

  // if flashActive, restore (so HUD/joystick are not scaled)
  if (flashActive) ctx.restore();

  // fog (skip during flashActive)
  if (!flashActive) {
    if (!fogCanvas) { fogCanvas = document.createElement('canvas'); fogCtx = fogCanvas.getContext('2d'); }
    fogCanvas.width = canvas.width;
    fogCanvas.height = canvas.height;

    fogCtx.globalCompositeOperation = 'source-over';
    fogCtx.fillStyle = '#000';
    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);

    fogCtx.globalCompositeOperation = 'destination-out';

    let glowR = TILE_SIZE * 5;
    let g = fogCtx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
    g.addColorStop(0.00, 'rgba(0,0,0,1)');
    g.addColorStop(0.60, 'rgba(0,0,0,0.5)');
    g.addColorStop(1.00, 'rgba(0,0,0,0)');
    fogCtx.fillStyle = g;
    fogCtx.beginPath();
    fogCtx.arc(cx, cy, glowR, 0, Math.PI * 2);
    fogCtx.fill();

    for (let b of bullets) {
      fogCtx.beginPath();
      fogCtx.arc(b.x + offX, b.y + offY, 30, 0, Math.PI * 2);
      fogCtx.fillStyle = 'rgba(0,0,0,1)';
      fogCtx.fill();
    }

    ctx.drawImage(fogCanvas, 0, 0);
  }

  // joysticks (pixel-adjust)
  drawJoystick(leftStick, "Move");
  drawJoystick(rightStick, "Aim");

  // goal direction arrow
  let angle = Math.atan2(goal.y - player.y, goal.x - player.x);
  let arrowDist = TILE_SIZE * 4;
  let ax = cx + Math.cos(angle) * arrowDist;
  let ay = cy + Math.sin(angle) * arrowDist;
  let arrowSize = 14;

  ctx.save();
  ctx.translate(ax, ay);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(arrowSize, 0);
  ctx.lineTo(-arrowSize, -arrowSize * 0.6);
  ctx.lineTo(-arrowSize * 0.4, 0);
  ctx.lineTo(-arrowSize, arrowSize * 0.6);
  ctx.closePath();
  ctx.fillStyle = 'rgb(255,255,255)';
  ctx.shadowColor = 'rgb(255,255,255)';
  ctx.shadowBlur = 10;
  ctx.fill();
  ctx.restore();
}

function drawJoystick(stick, label) {
  if (!stick.active) return;
  // convert screen coords -> pixel canvas coords
  let sx = stick.startX / PIXEL_SCALE, sy = stick.startY / PIXEL_SCALE;
  let cx = stick.currX / PIXEL_SCALE, cy = stick.currY / PIXEL_SCALE;

  ctx.beginPath();
  ctx.arc(sx, sy, 40 / PIXEL_SCALE, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(cx, cy, 20 / PIXEL_SCALE, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
  ctx.fill();

  ctx.fillStyle = '#fff';
  ctx.font = Math.floor(12 / PIXEL_SCALE) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(label, sx, sy + 60 / PIXEL_SCALE);
}

/* ==========================
   Game state
   ========================== */
function gameOver(type) {
  gameActive = false;
  if (type === 'win') {
    winScreen.style.display = 'flex';
  } else {
    playDeathSound();
    loseScreen.style.display = 'flex';
  }
}
function restart() { location.reload(); }
winScreen.addEventListener('click', restart);
loseScreen.addEventListener('click', restart);

function gameLoop() {
  updateMic();
  updateEffectsUI();
  updateObjectiveUI();

  if (gameActive) {
    updateAim();
    updatePlayerMovement();
    updateBullets();

    const now = Date.now();
    const invincible = now < effects.invincibleUntil;

    for (let g of ghosts) {
      if (!flashActive) g.update(player, map);
      if (!invincible && g.checkCollision(player)) {
        gameOver('lose');
        return;
      }
    }
  }

  draw();
  requestAnimationFrame(gameLoop);
}

/* ==========================
   Web Audio SFX
   ========================== */
function playGobackSound() {
  let ctxA = new AudioContext();
  let t = ctxA.currentTime;
  for (let i = 0; i < 2; i++) {
    let osc = ctxA.createOscillator();
    let gain = ctxA.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(200, t + i * 0.15);
    gain.gain.setValueAtTime(0.8, t + i * 0.15);
    gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.15 + 0.1);
    osc.connect(gain);
    gain.connect(ctxA.destination);
    osc.start(t + i * 0.15);
    osc.stop(t + i * 0.15 + 0.1);
  }
}

function playDeathSound() {
  let ctxA = new AudioContext();
  let t = ctxA.currentTime;

  let osc = ctxA.createOscillator();
  let gain = ctxA.createGain();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(500, t);
  osc.frequency.exponentialRampToValueAtTime(40, t + 0.8);
  gain.gain.setValueAtTime(1.0, t);
  gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
  osc.connect(gain);
  gain.connect(ctxA.destination);
  osc.start();
  osc.stop(t + 0.8);

  let buf = ctxA.createBuffer(1, ctxA.sampleRate * 0.5, ctxA.sampleRate);
  let data = buf.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
  let noise = ctxA.createBufferSource();
  let nGain = ctxA.createGain();
  noise.buffer = buf;
  nGain.gain.setValueAtTime(0.8, t);
  nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
  noise.connect(nGain);
  nGain.connect(ctxA.destination);
  noise.start();
}

function playFlashSound() {
  let ctxA = new AudioContext();
  let t = ctxA.currentTime;

  let osc1 = ctxA.createOscillator();
  let g1 = ctxA.createGain();
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(2000, t);
  osc1.frequency.exponentialRampToValueAtTime(500, t + 1.0);
  g1.gain.setValueAtTime(1.0, t);
  g1.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
  osc1.connect(g1);
  g1.connect(ctxA.destination);
  osc1.start();
  osc1.stop(t + 1.0);

  let osc2 = ctxA.createOscillator();
  let g2 = ctxA.createGain();
  osc2.type = 'triangle';
  osc2.frequency.setValueAtTime(150, t);
  g2.gain.setValueAtTime(0.7, t);
  g2.gain.exponentialRampToValueAtTime(0.01, t + 1.2);
  osc2.connect(g2);
  g2.connect(ctxA.destination);
  osc2.start();
  osc2.stop(t + 1.2);

  let buf = ctxA.createBuffer(1, ctxA.sampleRate * 0.3, ctxA.sampleRate);
  let data = buf.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
  let noise = ctxA.createBufferSource();
  let nGain = ctxA.createGain();
  noise.buffer = buf;
  nGain.gain.setValueAtTime(0.9, t);
  nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
  noise.connect(nGain);
  nGain.connect(ctxA.destination);
  noise.start();
}

/* ==========================
   Flash Grenade (overlay + show full map)
   ========================== */
const flashBtn = document.getElementById('flash-btn');
const flashOverlay = document.getElementById('flash-overlay');

flashBtn.addEventListener('click', () => {
  if (flashUsed || !gameActive) return;
  flashUsed = true;
  flashBtn.disabled = true;

  playFlashSound();

  setTimeout(() => {
    flashOverlay.style.display = 'flex';
    flashOverlay.style.background = '#fff';
    flashOverlay.style.opacity = '1';
    flashOverlay.className = '';

    setTimeout(() => {
      flashOverlay.classList.add('show-ad');

      setTimeout(() => {
        flashOverlay.classList.add('fade-out');
        flashOverlay.addEventListener('transitionend', function handler() {
          flashOverlay.removeEventListener('transitionend', handler);
          flashOverlay.style.display = 'none';
          flashOverlay.className = '';
          flashActive = true;
          setTimeout(() => { flashActive = false; }, 2000);
        });
      }, 1000);

    }, 500);
  }, 1500);
});

/* ==========================
   Start + Inputs
   ========================== */
startBtn.addEventListener('click', initAudio);

window.addEventListener('keydown', (e) => {
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d'].includes(e.key)) e.preventDefault();
  if (!activeKeys.includes(e.key)) activeKeys.push(e.key);
});
window.addEventListener('keyup', (e) => {
  activeKeys = activeKeys.filter(key => key !== e.key);
});
window.addEventListener('mousemove', (e) => {
  mousePos.x = e.clientX;
  mousePos.y = e.clientY;
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  for (let i = 0; i < e.changedTouches.length; i++) {
    let t = e.changedTouches[i];
    if (t.clientX < window.innerWidth / 2) {
      if (leftTouchId === null) {
        leftTouchId = t.identifier;
        leftStick.startX = t.clientX; leftStick.startY = t.clientY;
        leftStick.currX = t.clientX; leftStick.currY = t.clientY;
        leftStick.active = true;
      }
    } else {
      if (rightTouchId === null) {
        rightTouchId = t.identifier;
        rightStick.startX = t.clientX; rightStick.startY = t.clientY;
        rightStick.currX = t.clientX; rightStick.currY = t.clientY;
        rightStick.active = true;
      }
    }
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  for (let i = 0; i < e.changedTouches.length; i++) {
    let t = e.changedTouches[i];
    if (t.identifier === leftTouchId) { leftStick.currX = t.clientX; leftStick.currY = t.clientY; }
    else if (t.identifier === rightTouchId) { rightStick.currX = t.clientX; rightStick.currY = t.clientY; }
  }
}, { passive: false });

function endTouch(e) {
  e.preventDefault();
  for (let i = 0; i < e.changedTouches.length; i++) {
    let t = e.changedTouches[i];
    if (t.identifier === leftTouchId) { leftTouchId = null; leftStick.active = false; }
    else if (t.identifier === rightTouchId) { rightTouchId = null; rightStick.active = false; }
  }
}
canvas.addEventListener('touchend', endTouch);
canvas.addEventListener('touchcancel', endTouch);

// init objective UI right away
updateObjectiveUI();

// === ËÉåÊôØÈü≥Ê®Ç (from test_sounds.html) ===
let MUS = { playing:false };

function playSong(){
  if (MUS.playing) return;
  const AC = MUS.AC || (MUS.AC = new (window.AudioContext||window.webkitAudioContext)());
  if (AC.state === "suspended") AC.resume();

  MUS.playing = true;
  MUS.bpm = 132;
  MUS.step = 0;
  MUS.bar = 0;
  MUS.nextT = AC.currentTime + 0.05;
  MUS.lookAhead = 0.12;

  if (!MUS.master){
    const master = AC.createGain(); master.gain.value = 0.85;
    const comp = AC.createDynamicsCompressor();
    comp.threshold.value = -18; comp.knee.value = 25; comp.ratio.value = 10;
    comp.attack.value = 0.003; comp.release.value = 0.22;

    const dL = AC.createDelay(1), dR = AC.createDelay(1);
    dL.delayTime.value = 0.11; dR.delayTime.value = 0.145;
    const fbL = AC.createGain(), fbR = AC.createGain();
    fbL.gain.value = 0.35; fbR.gain.value = 0.33;

    const panL = AC.createStereoPanner(); panL.pan.value = -0.35;
    const panR = AC.createStereoPanner(); panR.pan.value =  0.35;

    dL.connect(fbL); fbL.connect(dL);
    dR.connect(fbR); fbR.connect(dR);

    const wet = AC.createGain(); wet.gain.value = 0.22;
    dL.connect(panL); panL.connect(wet);
    dR.connect(panR); panR.connect(wet);

    master.connect(comp);
    wet.connect(comp);
    comp.connect(AC.destination);

    MUS.master = master;
    MUS.wetSend = { dL, dR };
  }

  MUS.timer = setInterval(() => _songTick(), 25);
}

function stopSong(){
  MUS.playing = false;
  if (MUS.timer) clearInterval(MUS.timer);
  MUS.timer = null;
}

function _songTick(){
  const AC = MUS.AC;
  if (!MUS.playing || !AC) return;

  const spb = 60 / MUS.bpm;
  const stepDur = spb / 4;

  while (MUS.nextT < AC.currentTime + MUS.lookAhead){
    const s = MUS.step;

    const A = [72,null,74,null,79,null,77,null, 74,null,72,null,69,null,67,null];
    const B = [72,null,74,76, 79,null,77,76, 74,null,72,null,69,67,69,null];
    const C = [84,83,81,79, 77,76,74,72, 71,72,74,76, 77,79,81,83];

    const bars = MUS.bar % 16;
    let mel = A;
    if (bars >= 4 && bars < 8) mel = B;
    else if (bars >= 8 && bars < 12) mel = A;
    else if (bars >= 12) mel = C;

    const bass = [36,null,36,null, 34,null,34,null, 31,null,31,null, 33,null,33,null];

    const kick = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0];
    const sn   = [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0];
    const hat  = [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1];

    if (kick[s]) _kick(MUS.nextT);
    if (sn[s])   _snare(MUS.nextT);
    if (hat[s])  _hat(MUS.nextT);

    if (s % 2 === 0) _bass(MUS.nextT, bass[s] ?? 36);

    if (mel[s] != null) _lead(MUS.nextT, mel[s], (bars>=12?0.10:0.12));

    MUS.nextT += stepDur;
    MUS.step = (MUS.step + 1) & 15;
    if (MUS.step === 0) MUS.bar++;
  }
}

function _mtof(m){ return 440 * Math.pow(2, (m-69)/12); }

function _lead(t, midi, dur){
  const AC = MUS.AC, f = _mtof(midi);
  const o = AC.createOscillator();
  const g = AC.createGain();
  const lp = AC.createBiquadFilter();
  const pan = AC.createStereoPanner();

  o.type = "triangle";
  o.frequency.setValueAtTime(f, t);
  o.frequency.exponentialRampToValueAtTime(f*1.01, t+0.03);

  lp.type = "lowpass";
  lp.frequency.setValueAtTime(9000, t);
  lp.frequency.exponentialRampToValueAtTime(1800, t+dur);

  pan.pan.setValueAtTime(Math.sin((MUS.bar%8)/8*Math.PI*2)*0.35, t);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.28, t+0.006);
  g.gain.exponentialRampToValueAtTime(0.0001, t+dur);

  o.connect(lp); lp.connect(pan); pan.connect(g); g.connect(MUS.master);
  g.connect(MUS.wetSend.dL);
  g.connect(MUS.wetSend.dR);

  o.start(t); o.stop(t+dur+0.02);
}

function _bass(t, midi){
  const AC = MUS.AC, f = _mtof(midi);
  const o = AC.createOscillator();
  const g = AC.createGain();
  const lp = AC.createBiquadFilter();

  o.type = "sawtooth";
  o.frequency.setValueAtTime(f, t);
  o.frequency.exponentialRampToValueAtTime(f*0.985, t+0.12);

  lp.type = "lowpass";
  lp.frequency.setValueAtTime(600, t);
  lp.frequency.exponentialRampToValueAtTime(220, t+0.18);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.35, t+0.004);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);

  o.connect(lp); lp.connect(g); g.connect(MUS.master);
  o.start(t); o.stop(t+0.22);
}

function _kick(t){
  const AC = MUS.AC;
  const o = AC.createOscillator();
  const g = AC.createGain();

  o.type = "sine";
  o.frequency.setValueAtTime(140, t);
  o.frequency.exponentialRampToValueAtTime(38, t+0.10);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.95, t+0.002);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);

  o.connect(g); g.connect(MUS.master);
  o.start(t); o.stop(t+0.20);
}

function _snare(t){
  const AC = MUS.AC;
  const sr = AC.sampleRate, len = (sr*0.14)|0;
  const b = AC.createBuffer(1, len, sr);
  const d = b.getChannelData(0);
  for (let i=0;i<len;i++) d[i] = (Math.random()*2-1) * (1 - i/len);

  const n = AC.createBufferSource(); n.buffer = b;
  const bp = AC.createBiquadFilter(); bp.type="bandpass"; bp.frequency.value=1800; bp.Q.value=1.2;
  const g = AC.createGain();

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.55, t+0.003);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.14);

  n.connect(bp); bp.connect(g); g.connect(MUS.master);
  n.start(t); n.stop(t+0.16);
}

function _hat(t){
  const AC = MUS.AC;
  const sr = AC.sampleRate, len = (sr*0.03)|0;
  const b = AC.createBuffer(1, len, sr);
  const d = b.getChannelData(0);
  for (let i=0;i<len;i++) d[i] = (Math.random()*2-1);

  const n = AC.createBufferSource(); n.buffer = b;
  const hp = AC.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=6000;
  const g = AC.createGain();

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.18, t+0.001);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.03);

  n.connect(hp); hp.connect(g); g.connect(MUS.master);
  n.start(t); n.stop(t+0.04);
}

</script>
</body>
</html>
