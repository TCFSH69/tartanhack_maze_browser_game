<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; text-shadow: 1px 1px 2px #000; }
        #start-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; font-size: 20px; background: #0f0; color: #000; border: none; cursor: pointer; border-radius: 8px; }
    </style>
</head>
<body>
    <div id="ui">
        Mic Level: <span id="mic-val">0</span> <br>
        Ghosts: <span id="ghost-count">3</span>
    </div>
    <button id="start-btn">Start Game (Allow Mic)</button>
    <canvas id="gameCanvas"></canvas>

<script>
// ==========================================
// ★ Global Constants (遊戲參數設定區) ★
// ==========================================

// --- 地圖設定 ---
const TILE_SIZE = 20;
const MAP_WIDTH = 30;
const MAP_HEIGHT = 30;
const FLOOR_COLOR = '#2a2a2a';
const WALL_COLOR = '#6a6a6a';

// --- 玩家設定 ---
// 延遲幀數：越小越快。4 代表每 4 幀 (約0.06秒) 移動一格
const PLAYER_MOVE_DELAY = 20; 

// --- 鬼 (Ghost) 設定 ---
const GHOST_COUNT = 3;       // 鬼的數量
const GHOST_SPEED = 0.25;    // 鬼的速度 (玩家是 5，這裡是 1.25，即玩家的 1/4)
const GHOST_RESPAWN_TIME = 300; // 復活時間 (幀數)，300幀約等於 5 秒 (60fps)

// --- 戰鬥設定 ---
const BULLET_SPEED = 4;      // 子彈速度
const FIRE_THRESHOLD = 50;   // 麥克風音量閾值 (0-255)
const FIRE_COOLDOWN = 400;   // 發射冷卻 (毫秒)

// ==========================================

// --- 全域變數 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiMic = document.getElementById('mic-val');
const uiGhostCount = document.getElementById('ghost-count');

let map = [];
let player = { x: 2, y: 2, dirX: 0, dirY: 1, moveTimer: 0 };
let goal = { x: 0, y: 0 };
let bullets = [];
let lastFireTime = 0;
let ghosts = []; // 改為陣列存放多隻鬼
let fogCanvas, fogCtx;

let audioContext, analyser, dataArray;
let micLevel = 0;

let activeKeys = []; 

// --- Ghost Class ---
class Ghost {
    constructor(startX, startY) {
        this.x = startX * TILE_SIZE;
        this.y = startY * TILE_SIZE;
        this.size = 18;
        this.color = 'red';
        this.speed = GHOST_SPEED; 
        this.targetX = this.x;
        this.targetY = this.y;
        this.isDead = false;
        this.respawnTimer = 0; // 復活倒數計時器
    }

    update(player, map) {
        // 1. 如果死了，處理復活邏輯
        if (this.isDead) {
            this.respawnTimer--;
            if (this.respawnTimer <= 0) {
                this.respawn();
            }
            return;
        }

        // 2. 移動邏輯：往目標點靠近
        let dist = Math.abs(this.x - this.targetX) + Math.abs(this.y - this.targetY);
        if (dist < this.speed) {
            this.x = this.targetX;
            this.y = this.targetY;
            
            // 到達格子中心後，計算下一步 (BFS)
            let gx = Math.round(this.x / TILE_SIZE);
            let gy = Math.round(this.y / TILE_SIZE);
            let next = this.bfs(gx, gy, player.x, player.y, map);
            if (next) {
                this.targetX = next.x * TILE_SIZE;
                this.targetY = next.y * TILE_SIZE;
            }
        }

        // 移動像素
        if (this.x < this.targetX) this.x += this.speed;
        if (this.x > this.targetX) this.x -= this.speed;
        if (this.y < this.targetY) this.y += this.speed;
        if (this.y > this.targetY) this.y -= this.speed;
    }

    // 復活函數：隨機找一個離玩家遠的地方重生
    respawn() {
        let maxAttempts = 100;
        while (maxAttempts > 0) {
            let rx = Math.floor(Math.random() * MAP_WIDTH);
            let ry = Math.floor(Math.random() * MAP_HEIGHT);
            // 必須是地板，且離玩家有一段距離
            if (map[ry][rx] === 1 && Math.abs(rx - player.x) + Math.abs(ry - player.y) > 15) {
                this.x = rx * TILE_SIZE;
                this.y = ry * TILE_SIZE;
                this.targetX = this.x;
                this.targetY = this.y;
                this.isDead = false;
                break;
            }
            maxAttempts--;
        }
    }

    bfs(sx, sy, ex, ey, map) {
        if (sx === ex && sy === ey) return null;
        let queue = [{x: sx, y: sy}];
        let from = {};
        let sk = `${sx},${sy}`;
        from[sk] = null;
        let found = false;
        
        // 為了效能，BFS 限制搜索深度
        let iterations = 0;
        while (queue.length > 0 && iterations < 800) {
            iterations++;
            let c = queue.shift();
            if (c.x === ex && c.y === ey) { found = true; break; }
            for (let [dx, dy] of [[0,-1],[0,1],[-1,0],[1,0]]) {
                let nx = c.x + dx, ny = c.y + dy, k = `${nx},${ny}`;
                if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT &&
                    map[ny][nx] === 1 && !from.hasOwnProperty(k)) {
                    queue.push({x: nx, y: ny});
                    from[k] = {x: c.x, y: c.y};
                }
            }
        }
        if (!found) return null;
        let ck = `${ex},${ey}`, path = [];
        if (!from[ck]) return null; 
        
        while (ck !== sk) {
            let p = ck.split(',').map(Number);
            path.push({x: p[0], y: p[1]});
            let pr = from[ck];
            ck = `${pr.x},${pr.y}`;
        }
        return path[path.length - 1];
    }

    checkCollision(player) {
        if (this.isDead) return false;
        let px = player.x * TILE_SIZE, py = player.y * TILE_SIZE;
        return this.x < px + TILE_SIZE - 4 && this.x + this.size > px + 4 &&
               this.y < py + TILE_SIZE - 4 && this.y + this.size > py + 4;
    }

    draw(ctx, offX, offY) {
        if (this.isDead) return;
        let sx = this.x + offX, sy = this.y + offY;
        ctx.fillStyle = this.color;
        ctx.fillRect(sx, sy, this.size, this.size);
        // 眼睛
        let ex = this.targetX > this.x ? 2 : this.targetX < this.x ? -2 : 0;
        let ey = this.targetY > this.y ? 2 : this.targetY < this.y ? -2 : 0;
        ctx.fillStyle = 'white';
        ctx.fillRect(sx + 4 + ex, sy + 4 + ey, 5, 5);
        ctx.fillRect(sx + 10 + ex, sy + 4 + ey, 5, 5);
    }
}

// --- 地圖生成 ---
function generateMap() {
    map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
        let row = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
            if (x === 0 || x === MAP_WIDTH - 1 || y === 0 || y === MAP_HEIGHT - 1 || Math.random() < 0.2) {
                row.push(0);
            } else {
                row.push(1);
            }
        }
        map.push(row);
    }
    // 起點區域
    for (let cy = 1; cy <= 3; cy++) for (let cx = 1; cx <= 3; cx++) map[cy][cx] = 1;
    player.x = 2; player.y = 2; player.dirX = 0; player.dirY = 1;

    // 終點
    while (true) {
        let gx = Math.floor(Math.random() * MAP_WIDTH);
        let gy = Math.floor(Math.random() * MAP_HEIGHT);
        if (map[gy][gx] === 1 && (gx > 10 || gy > 10)) {
            goal = { x: gx, y: gy };
            break;
        }
    }
    
    // 生成多隻鬼
    ghosts = [];
    for (let i = 0; i < GHOST_COUNT; i++) {
        while (true) {
            let sx = Math.floor(Math.random() * MAP_WIDTH);
            let sy = Math.floor(Math.random() * MAP_HEIGHT);
            if (map[sy][sx] === 1 && Math.abs(sx - player.x) + Math.abs(sy - player.y) > 15) {
                ghosts.push(new Ghost(sx, sy));
                break;
            }
        }
    }
}

// --- 音訊 ---
async function initAudio() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') await audioContext.resume();
        analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        document.getElementById('start-btn').style.display = 'none';
        gameLoop();
    } catch (e) {
        alert("Microphone denied!");
    }
}

function updateMic() {
    if (!analyser) return;
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
    let avg = sum / dataArray.length;

    micLevel = Math.min(10, Math.floor(avg / 10));
    uiMic.innerText = micLevel + ` (dB: ${Math.floor(avg)})`;

    // 發射子彈
    if (avg > FIRE_THRESHOLD && Date.now() - lastFireTime > FIRE_COOLDOWN) {
        fireBullet();
        lastFireTime = Date.now();
    }
}

// --- 戰鬥系統 ---
function fireBullet() {
    bullets.push({
        x: player.x * TILE_SIZE + TILE_SIZE / 2,
        y: player.y * TILE_SIZE + TILE_SIZE / 2,
        vx: player.dirX * BULLET_SPEED,
        vy: player.dirY * BULLET_SPEED
    });
}

function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;

        let gx = Math.floor(b.x / TILE_SIZE);
        let gy = Math.floor(b.y / TILE_SIZE);
        
        // 撞牆
        if (gx < 0 || gx >= MAP_WIDTH || gy < 0 || gy >= MAP_HEIGHT || map[gy][gx] === 0) {
            bullets.splice(i, 1);
            continue;
        }
        
        // 撞鬼檢測 (迴圈檢查所有鬼)
        for (let g of ghosts) {
            if (!g.isDead) {
                if (b.x > g.x && b.x < g.x + g.size &&
                    b.y > g.y && b.y < g.y + g.size) {
                    
                    g.isDead = true;
                    g.respawnTimer = GHOST_RESPAWN_TIME; // 設定復活倒數
                    bullets.splice(i, 1);
                    break; // 子彈消失，跳出鬼的迴圈
                }
            }
        }
    }
}

// --- 玩家移動 ---
function updatePlayerMovement() {
    if (player.moveTimer > 0) {
        player.moveTimer--;
        return;
    }

    let dx = 0;
    let dy = 0;

    if (activeKeys.length > 0) {
        const lastKey = activeKeys[activeKeys.length - 1];
        if (lastKey === 'w' || lastKey === 'ArrowUp') dy = -1;
        else if (lastKey === 's' || lastKey === 'ArrowDown') dy = 1;
        else if (lastKey === 'a' || lastKey === 'ArrowLeft') dx = -1;
        else if (lastKey === 'd' || lastKey === 'ArrowRight') dx = 1;
    }

    if (dx !== 0 || dy !== 0) {
        player.dirX = dx;
        player.dirY = dy;
        let newX = player.x + dx;
        let newY = player.y + dy;

        if (newX >= 0 && newX < MAP_WIDTH && newY >= 0 && newY < MAP_HEIGHT && map[newY][newX] === 1) {
            player.x = newX;
            player.y = newY;
            player.moveTimer = PLAYER_MOVE_DELAY;
            
            if (player.x === goal.x && player.y === goal.y) {
                alert("You Win! Refresh to restart.");
                location.reload();
            }
        }
    }
}

// --- 渲染 ---
function draw() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let offX = (canvas.width / 2) - (player.x * TILE_SIZE) - (TILE_SIZE / 2);
    let offY = (canvas.height / 2) - (player.y * TILE_SIZE) - (TILE_SIZE / 2);

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 地圖
    let cols = Math.ceil(canvas.width / TILE_SIZE);
    let rows = Math.ceil(canvas.height / TILE_SIZE);
    let startCol = Math.floor(-offX / TILE_SIZE);
    let startRow = Math.floor(-offY / TILE_SIZE);

    for (let y = startRow; y <= startRow + rows; y++) {
        for (let x = startCol; x <= startCol + cols; x++) {
            if (y >= 0 && y < MAP_HEIGHT && x >= 0 && x < MAP_WIDTH) {
                let px = x * TILE_SIZE + offX;
                let py = y * TILE_SIZE + offY;
                ctx.fillStyle = map[y][x] === 0 ? WALL_COLOR : FLOOR_COLOR;
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // 子彈
    ctx.fillStyle = '#ffff00';
    for (let b of bullets) {
        ctx.beginPath();
        ctx.arc(b.x + offX, b.y + offY, 4, 0, Math.PI * 2);
        ctx.fill();
    }

    // 玩家
    let pX = player.x * TILE_SIZE + offX;
    let pY = player.y * TILE_SIZE + offY;
    ctx.fillStyle = '#0f0';
    ctx.fillRect(pX, pY, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(pX + TILE_SIZE/2 + player.dirX*6, pY + TILE_SIZE/2 + player.dirY*6, 2.2, 0, Math.PI*2);
    ctx.fill();

    // 鬼 (畫出所有活著的鬼)
    let aliveCount = 0;
    for (let g of ghosts) {
        g.draw(ctx, offX, offY);
        if (!g.isDead) aliveCount++;
    }
    // 更新介面顯示活著的鬼的數量
    uiGhostCount.innerText = aliveCount;

    // 終點
    let gX = goal.x * TILE_SIZE + offX;
    let gY = goal.y * TILE_SIZE + offY;
    ctx.fillStyle = 'gold';
    ctx.font = '16px Arial';
    ctx.fillText('\u{1F6A9}', gX, gY + 16);

    // --- Fog of War ---
    if (!fogCanvas) {
        fogCanvas = document.createElement('canvas');
        fogCtx = fogCanvas.getContext('2d');
    }
    fogCanvas.width = canvas.width;
    fogCanvas.height = canvas.height;
    
    fogCtx.globalCompositeOperation = 'source-over';
    fogCtx.fillStyle = '#000';
    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);

    fogCtx.globalCompositeOperation = 'destination-out';

    let cx = pX + TILE_SIZE / 2, cy = pY + TILE_SIZE / 2;
    let glowR = TILE_SIZE * 5; 
    let g = fogCtx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
    g.addColorStop(0.00, 'rgba(0,0,0,1)');
    g.addColorStop(0.60, 'rgba(0,0,0,0.5)'); 
    g.addColorStop(1.00, 'rgba(0,0,0,0)');
    fogCtx.fillStyle = g;
    fogCtx.beginPath();
    fogCtx.arc(cx, cy, glowR, 0, Math.PI * 2);
    fogCtx.fill();

    for (let b of bullets) {
        fogCtx.beginPath();
        fogCtx.arc(b.x + offX, b.y + offY, 30, 0, Math.PI * 2);
        fogCtx.fillStyle = 'rgba(0,0,0,1)';
        fogCtx.fill();
    }

    ctx.drawImage(fogCanvas, 0, 0);

    // 終點箭頭
    let angle = Math.atan2(goal.y - player.y, goal.x - player.x);
    let arrowDist = TILE_SIZE * 4;
    let ax = cx + Math.cos(angle) * arrowDist;
    let ay = cy + Math.sin(angle) * arrowDist;
    let arrowSize = 14;
    ctx.save();
    ctx.translate(ax, ay);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(arrowSize, 0);
    ctx.lineTo(-arrowSize, -arrowSize * 0.6);
    ctx.lineTo(-arrowSize * 0.4, 0);
    ctx.lineTo(-arrowSize, arrowSize * 0.6);
    ctx.closePath();
    ctx.fillStyle = 'rgb(255,255,255)';
    ctx.shadowColor = 'rgb(255,255,255)';
    ctx.shadowBlur = 6;
    ctx.fill();
    ctx.restore();
}

function gameLoop() {
    updateMic();
    updatePlayerMovement();
    updateBullets();
    
    // 更新所有鬼
    for (let g of ghosts) {
        g.update(player, map);
        if (g.checkCollision(player)) {
            alert("Caught by ghost! Game Over.");
            location.reload();
            return;
        }
    }

    draw();
    requestAnimationFrame(gameLoop);
}

// 啟動
document.getElementById('start-btn').addEventListener('click', () => {
    generateMap();
    initAudio();
});

// 鍵盤
window.addEventListener('keydown', (e) => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    if (!activeKeys.includes(e.key)) activeKeys.push(e.key);
});
window.addEventListener('keyup', (e) => {
    activeKeys = activeKeys.filter(key => key !== e.key);
});

// 觸控
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const cx = window.innerWidth / 2;
    const cy = window.innerHeight / 2;
    let key = '';
    if (Math.abs(touch.clientX - cx) > Math.abs(touch.clientY - cy)) {
        key = touch.clientX < cx ? 'ArrowLeft' : 'ArrowRight';
    } else {
        key = touch.clientY < cy ? 'ArrowUp' : 'ArrowDown';
    }
    if (!activeKeys.includes(key)) activeKeys = [key];
}, { passive: false });

canvas.addEventListener('touchend', () => {
    activeKeys = [];
});
</script>
</body>
</html>