<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Sound Effects Test</title>
    <style>
        body { background: #111; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 40px; }
        h1 { margin-bottom: 30px; }
        button {
            padding: 20px 40px; margin: 10px; font-size: 18px; font-weight: bold;
            border: 2px solid #fff; border-radius: 10px; cursor: pointer;
            min-width: 300px;
        }
        .flash { background: #ffd700; color: #000; }
        .death { background: #ff2222; color: #fff; }
        .goback { background: #888; color: #000; }
        .hit { background: #ff8800; color: #000; }
        .laser { background: #00ff88; color: #000; }
        .powerup { background: #aa00ff; color: #fff; }
        .explosion { background: #ff4400; color: #fff; }
        .alarm { background: #ff0066; color: #fff; }
        .coin { background: #ffee00; color: #000; }
        .jump { background: #0088ff; color: #fff; }
        .funny { background: #ff69b4; color: #000; }
        .cool { background: linear-gradient(135deg, #0ff, #f0f); color: #000; }
        .scream { background: linear-gradient(135deg, #f00, #ff6600); color: #fff; font-weight: bold; }
        h2 { margin-top: 30px; color: #888; }
    </style>
</head>
<body>
    <h1>Sound Effects Tester</h1>

    <h2>-- Game SFX --</h2>
    <button class="flash" onclick="playFlash()">Flash Grenade (閃光彈)</button>
    <button class="death" onclick="playDeath()">Death (死亡)</button>
    <button class="goback" onclick="playGoback()">Dead End (死胡同)</button>
    <button class="hit" onclick="playHit()">Hit / Damage (被打)</button>
    <button class="laser" onclick="playLaser()">Laser Shoot (雷射)</button>
    <button class="powerup" onclick="playPowerup()">Power Up (加強)</button>
    <button class="explosion" onclick="playExplosion()">Explosion (爆炸)</button>
    <button class="alarm" onclick="playAlarm()">Alarm / Danger (警報)</button>
    <button class="coin" onclick="playCoin()">Coin / Pickup (撿東西)</button>
    <button class="jump" onclick="playJump()">Jump (跳躍)</button>

    <h2>-- Funny SFX --</h2>
    <button class="funny" onclick="playFart()">Fart (放屁)</button>
    <button class="funny" onclick="playBoing()">Boing (彈簧)</button>
    <button class="funny" onclick="playSlideWhistle()">Slide Whistle (滑哨)</button>
    <button class="funny" onclick="playBonk()">Bonk (撞頭)</button>
    <button class="funny" onclick="playSadTrombone()">Sad Trombone (失敗)</button>
    <button class="funny" onclick="playQuack()">Duck Quack (鴨叫)</button>
    <button class="funny" onclick="playWooop()">Wooop (搞笑警車)</button>
    <button class="funny" onclick="playBubble()">Bubble Pop (泡泡)</button>

    <h2>-- COOL SFX --</h2>
    <button class="cool" onclick="playInception()">INCEPTION BWAAAAM (全境啟動)</button>
    <button class="cool" onclick="playDubstep()">Dubstep Drop (電子低音)</button>
    <button class="cool" onclick="playLightsaber()">Lightsaber (光劍)</button>
    <button class="cool" onclick="playThunder()">Thunder (雷擊)</button>
    <button class="cool" onclick="playGlitch()">Digital Glitch (數位故障)</button>
    <button class="cool" onclick="playWarp()">Sci-Fi Warp (傳送)</button>
    <button class="cool" onclick="playHeartbeat()">Heartbeat (心跳)</button>
    <button class="cool" onclick="playRewind()">Tape Rewind (倒帶)</button>
    <button class="cool" onclick="playEpicHit()">Epic Hit (史詩重擊)</button>
    <button class="cool" onclick="playRiser()">Tension Riser (緊張上升)</button>
    <button class="cool" onclick="playDemonVoice()">Demon Voice (惡魔低語)</button>
    <button class="cool" onclick="playMatrixBullet()">Matrix Bullet Time (駭客子彈)</button>

    <h2>-- SCREAM / ROAR SFX --</h2>
    <button class="scream" onclick="playHumanScream()">Human Scream (人類尖叫)</button>
    <button class="scream" onclick="playMonsterRoar()">Monster Roar (怪物吼叫)</button>
    <button class="scream" onclick="playBanshee()">Banshee Shriek (女鬼尖叫)</button>
    <button class="scream" onclick="playWarCry()">War Cry (戰吼)</button>
    <button class="scream" onclick="playZombie()">Zombie Groan (殭屍呻吟)</button>
    <button class="scream" onclick="playBeastGrowl()">Beast Growl (野獸低吼)</button>
    <button class="scream" onclick="playGhostWail()">Ghost Wail (鬼魂哀號)</button>
    <button class="scream" onclick="playDragonRoar()">Dragon Roar (龍吼)</button>
    <button class="scream" onclick="playPanicScream()">Panic Scream (恐慌尖叫)</button>
    <button class="scream" onclick="playDemonScream()">Demon Scream (惡魔嘶吼)</button>

    <button onclick="playCyberKatana()">Cyber Katana</button>
    <button onclick="playPortalPop()">Portal Pop</button>
    <button onclick="playNeonConfirm()">Neon Confirm</button>
    <button onclick="playBossSpawn()">Boss Spawn</button>
    <button onclick="playTimeFreeze()">Time Freeze</button>
    <button onclick="playDataCorrupt()">Data Corrupt</button>
    <!-- 貼在你 COOL SFX 區塊裡（或任何地方都行） -->
    <button class="cool" onclick="playWormhole()">Wormhole Warp (蟲洞傳送)</button>
    <button class="cool" onclick="playAntimatterSlam()">Antimatter Slam (反物質重擊)</button>
    <button class="cool" onclick="playNeuralSnap()">Neural Snap (神經脈衝)</button>
    <button class="cool" onclick="playQuantumGlitter()">Quantum Glitter (量子閃鑽)</button>


<script>
// 1. 閃光彈 — 高頻爆閃 + 嗡鳴
function playFlash() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc1 = ctx.createOscillator();
    let g1 = ctx.createGain();
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(2000, t);
    osc1.frequency.exponentialRampToValueAtTime(500, t + 1.0);
    g1.gain.setValueAtTime(1.0, t);
    g1.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
    osc1.connect(g1); g1.connect(ctx.destination);
    osc1.start(); osc1.stop(t + 1.0);

    let osc2 = ctx.createOscillator();
    let g2 = ctx.createGain();
    osc2.type = 'triangle';
    osc2.frequency.setValueAtTime(150, t);
    g2.gain.setValueAtTime(0.7, t);
    g2.gain.exponentialRampToValueAtTime(0.01, t + 1.2);
    osc2.connect(g2); g2.connect(ctx.destination);
    osc2.start(); osc2.stop(t + 1.2);

    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.9, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 2. 死亡 — 重擊下降 + 噪音
function playDeath() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(500, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.8);
    gain.gain.setValueAtTime(1.0, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.8);

    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.8, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 3. 死胡同 — 兩聲短促低音
function playGoback() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let i = 0; i < 2; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, t + i * 0.15);
        gain.gain.setValueAtTime(0.8, t + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.15 + 0.1);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(t + i * 0.15); osc.stop(t + i * 0.15 + 0.1);
    }
}

// 4. 被打 — 短促中頻衝擊
function playHit() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(300, t);
    osc.frequency.exponentialRampToValueAtTime(100, t + 0.2);
    gain.gain.setValueAtTime(1.0, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.2);

    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.15, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.6, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 5. 雷射 — 高頻快速下降
function playLaser() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(1500, t);
    osc.frequency.exponentialRampToValueAtTime(200, t + 0.15);
    gain.gain.setValueAtTime(0.8, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.15);
}

// 6. 加強 — 上升音階
function playPowerup() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let freqs = [400, 500, 630, 800];
    for (let i = 0; i < freqs.length; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freqs[i], t + i * 0.1);
        gain.gain.setValueAtTime(0.7, t + i * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.1 + 0.15);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(t + i * 0.1); osc.stop(t + i * 0.1 + 0.15);
    }
}

// 7. 爆炸 — 重低音 + 大量噪音
function playExplosion() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(100, t);
    osc.frequency.exponentialRampToValueAtTime(20, t + 1.0);
    gain.gain.setValueAtTime(1.0, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 1.0);

    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.8, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(1.0, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 8. 警報 — 反覆高低音交替
function playAlarm() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let i = 0; i < 6; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(i % 2 === 0 ? 800 : 600, t + i * 0.12);
        gain.gain.setValueAtTime(0.7, t + i * 0.12);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.12 + 0.1);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(t + i * 0.12); osc.stop(t + i * 0.12 + 0.1);
    }
}

// 9. 撿東西 — 清脆兩音
function playCoin() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let freqs = [900, 1200];
    for (let i = 0; i < 2; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freqs[i], t + i * 0.08);
        gain.gain.setValueAtTime(0.8, t + i * 0.08);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.08 + 0.15);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(t + i * 0.08); osc.stop(t + i * 0.08 + 0.15);
    }
}

// 10. 跳躍 — 快速上升音
function playJump() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(300, t);
    osc.frequency.exponentialRampToValueAtTime(800, t + 0.15);
    gain.gain.setValueAtTime(0.8, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.2);
}

// ========== FUNNY SFX ==========

// 放屁 — 低頻震動 + 噪音
function playFart() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(80, t);
    osc.frequency.linearRampToValueAtTime(60, t + 0.1);
    osc.frequency.linearRampToValueAtTime(90, t + 0.2);
    osc.frequency.linearRampToValueAtTime(50, t + 0.4);
    gain.gain.setValueAtTime(0.6, t);
    gain.gain.setValueAtTime(0.8, t + 0.1);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.5);
    // 噪音氣流
    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.4, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(300, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.4, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
    noise.connect(filter); filter.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 彈簧 — 快速上下彈跳
function playBoing() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(1200, t + 0.05);
    osc.frequency.exponentialRampToValueAtTime(400, t + 0.15);
    osc.frequency.exponentialRampToValueAtTime(900, t + 0.2);
    osc.frequency.exponentialRampToValueAtTime(300, t + 0.35);
    gain.gain.setValueAtTime(0.9, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.4);
}

// 滑哨 — 慢速上升再下降
function playSlideWhistle() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(400, t);
    osc.frequency.linearRampToValueAtTime(1500, t + 0.4);
    osc.frequency.linearRampToValueAtTime(300, t + 0.8);
    gain.gain.setValueAtTime(0.8, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.9);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.9);
}

// 撞頭 — 短促重擊 + 星星音
function playBonk() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 重擊
    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(1.0, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
    // 星星轉圈音
    let freqs = [1200, 1400, 1100, 1300];
    for (let i = 0; i < freqs.length; i++) {
        let osc = ctx.createOscillator();
        let g = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freqs[i], t + 0.05 + i * 0.08);
        g.gain.setValueAtTime(0.5, t + 0.05 + i * 0.08);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.05 + i * 0.08 + 0.1);
        osc.connect(g); g.connect(ctx.destination);
        osc.start(t + 0.05 + i * 0.08); osc.stop(t + 0.05 + i * 0.08 + 0.1);
    }
}

// 失敗喇叭 — wah wah wah wahhh
function playSadTrombone() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let notes = [350, 330, 310, 200];
    let durations = [0.3, 0.3, 0.3, 0.8];
    let offset = 0;
    for (let i = 0; i < notes.length; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(notes[i], t + offset);
        if (i === 3) osc.frequency.linearRampToValueAtTime(150, t + offset + durations[i]);
        gain.gain.setValueAtTime(0.8, t + offset);
        gain.gain.setValueAtTime(0.8, t + offset + durations[i] * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.01, t + offset + durations[i]);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(t + offset); osc.stop(t + offset + durations[i]);
        offset += durations[i];
    }
}

// 鴨叫 — 短促鼻音
function playQuack() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let i = 0; i < 2; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, t + i * 0.2);
        osc.frequency.exponentialRampToValueAtTime(500, t + i * 0.2 + 0.08);
        let filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1200, t + i * 0.2);
        filter.Q.setValueAtTime(5, t + i * 0.2);
        gain.gain.setValueAtTime(0.9, t + i * 0.2);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.2 + 0.12);
        osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
        osc.start(t + i * 0.2); osc.stop(t + i * 0.2 + 0.12);
    }
}

// 搞笑警車 — wee-woo 快速版
function playWooop() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, t);
    for (let i = 0; i < 4; i++) {
        osc.frequency.linearRampToValueAtTime(1000, t + i * 0.2 + 0.1);
        osc.frequency.linearRampToValueAtTime(600, t + i * 0.2 + 0.2);
    }
    gain.gain.setValueAtTime(0.8, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 0.8);
}

// 泡泡 — 短促水泡音
function playBubble() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let i = 0; i < 3; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'sine';
        let baseFreq = 600 + Math.random() * 400;
        osc.frequency.setValueAtTime(baseFreq, t + i * 0.12);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, t + i * 0.12 + 0.08);
        gain.gain.setValueAtTime(0.7, t + i * 0.12);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.12 + 0.1);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(t + i * 0.12); osc.stop(t + i * 0.12 + 0.1);
    }
}

// ========== COOL SFX ==========

// INCEPTION BWAAAAM — 超低頻轟鳴 + 多層疊加
function playInception() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 主轟鳴
    let osc1 = ctx.createOscillator();
    let g1 = ctx.createGain();
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(55, t);
    osc1.frequency.linearRampToValueAtTime(40, t + 2.5);
    g1.gain.setValueAtTime(0, t);
    g1.gain.linearRampToValueAtTime(1.0, t + 0.1);
    g1.gain.setValueAtTime(1.0, t + 0.5);
    g1.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    osc1.connect(g1); g1.connect(ctx.destination);
    osc1.start(); osc1.stop(t + 2.5);
    // 泛音層
    let osc2 = ctx.createOscillator();
    let g2 = ctx.createGain();
    osc2.type = 'square';
    osc2.frequency.setValueAtTime(110, t);
    osc2.frequency.linearRampToValueAtTime(80, t + 2.5);
    g2.gain.setValueAtTime(0, t);
    g2.gain.linearRampToValueAtTime(0.5, t + 0.1);
    g2.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    osc2.connect(g2); g2.connect(ctx.destination);
    osc2.start(); osc2.stop(t + 2.5);
    // 噪音衝擊
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.setValueAtTime(200, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0, t);
    nGain.gain.linearRampToValueAtTime(0.6, t + 0.1);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    noise.connect(lp); lp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// Dubstep Drop — LFO wobble bass
function playDubstep() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let filter = ctx.createBiquadFilter();
    let lfo = ctx.createOscillator();
    let lfoGain = ctx.createGain();
    let gain = ctx.createGain();
    // bass
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(60, t);
    // wobble filter
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(300, t);
    filter.Q.setValueAtTime(15, t);
    // LFO 控制 filter
    lfo.type = 'sine';
    lfo.frequency.setValueAtTime(3, t);
    lfo.frequency.linearRampToValueAtTime(15, t + 1.5);
    lfoGain.gain.setValueAtTime(1500, t);
    lfo.connect(lfoGain);
    lfoGain.connect(filter.frequency);
    gain.gain.setValueAtTime(1.0, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
    osc.start(); lfo.start();
    osc.stop(t + 2.0); lfo.stop(t + 2.0);
}

// 光劍 — 持續嗡鳴 + 揮動
function playLightsaber() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 啟動上升音
    let osc1 = ctx.createOscillator();
    let g1 = ctx.createGain();
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(80, t);
    osc1.frequency.exponentialRampToValueAtTime(200, t + 0.3);
    osc1.frequency.setValueAtTime(200, t + 0.5);
    // 揮動
    osc1.frequency.linearRampToValueAtTime(350, t + 0.7);
    osc1.frequency.linearRampToValueAtTime(150, t + 1.0);
    osc1.frequency.linearRampToValueAtTime(300, t + 1.2);
    osc1.frequency.linearRampToValueAtTime(200, t + 1.5);
    g1.gain.setValueAtTime(0, t);
    g1.gain.linearRampToValueAtTime(0.6, t + 0.2);
    g1.gain.setValueAtTime(0.6, t + 1.2);
    g1.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.setValueAtTime(800, t);
    osc1.connect(lp); lp.connect(g1); g1.connect(ctx.destination);
    osc1.start(); osc1.stop(t + 1.5);
    // 高頻能量層
    let osc2 = ctx.createOscillator();
    let g2 = ctx.createGain();
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(600, t + 0.3);
    osc2.frequency.linearRampToValueAtTime(900, t + 0.7);
    osc2.frequency.linearRampToValueAtTime(500, t + 1.0);
    g2.gain.setValueAtTime(0, t);
    g2.gain.linearRampToValueAtTime(0.3, t + 0.3);
    g2.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
    osc2.connect(g2); g2.connect(ctx.destination);
    osc2.start(); osc2.stop(t + 1.5);
}

// 雷擊 — 噪音爆破 + 低頻滾動
function playThunder() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 閃電劈裂
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        let env = Math.exp(-i / (ctx.sampleRate * 0.5));
        data[i] = (Math.random() * 2 - 1) * env;
        // 隨機斷裂感
        if (Math.random() < 0.001) data[i] *= 5;
    }
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.setValueAtTime(3000, t);
    lp.frequency.exponentialRampToValueAtTime(100, t + 1.5);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(1.0, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    noise.connect(lp); lp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
    // 低頻滾動
    let osc = ctx.createOscillator();
    let g = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(50, t + 0.2);
    osc.frequency.linearRampToValueAtTime(30, t + 2.0);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.8, t + 0.3);
    g.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    osc.connect(g); g.connect(ctx.destination);
    osc.start(); osc.stop(t + 2.0);
}

// 數位故障 — 隨機頻率跳躍 + 碎裂噪音
function playGlitch() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let i = 0; i < 12; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = ['square', 'sawtooth'][Math.floor(Math.random() * 2)];
        let freq = 100 + Math.random() * 2000;
        let start = t + i * 0.06;
        let dur = 0.02 + Math.random() * 0.06;
        osc.frequency.setValueAtTime(freq, start);
        gain.gain.setValueAtTime(0.7, start);
        gain.gain.setValueAtTime(0, start + dur);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(start); osc.stop(start + dur);
    }
    // 碎裂噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        data[i] = Math.random() < 0.1 ? (Math.random() * 2 - 1) : 0;
    }
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.8, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.7);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 傳送 — 上升旋轉 + 爆發
function playWarp() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 旋轉上升
    let osc1 = ctx.createOscillator();
    let g1 = ctx.createGain();
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(200, t);
    osc1.frequency.exponentialRampToValueAtTime(3000, t + 0.8);
    g1.gain.setValueAtTime(0.3, t);
    g1.gain.linearRampToValueAtTime(0.9, t + 0.7);
    g1.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
    osc1.connect(g1); g1.connect(ctx.destination);
    osc1.start(); osc1.stop(t + 1.0);
    // 第二層延遲跟隨
    let osc2 = ctx.createOscillator();
    let g2 = ctx.createGain();
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(250, t + 0.05);
    osc2.frequency.exponentialRampToValueAtTime(3500, t + 0.85);
    g2.gain.setValueAtTime(0.2, t + 0.05);
    g2.gain.linearRampToValueAtTime(0.7, t + 0.75);
    g2.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
    osc2.connect(g2); g2.connect(ctx.destination);
    osc2.start(); osc2.stop(t + 1.0);
    // 爆發噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0, t);
    nGain.gain.setValueAtTime(1.0, t + 0.8);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 心跳 — 雙擊低音
function playHeartbeat() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let beat = 0; beat < 3; beat++) {
        let base = t + beat * 0.8;
        // 第一下 (重)
        let o1 = ctx.createOscillator();
        let g1 = ctx.createGain();
        o1.type = 'sine'; o1.frequency.setValueAtTime(50, base);
        g1.gain.setValueAtTime(1.0, base);
        g1.gain.exponentialRampToValueAtTime(0.01, base + 0.15);
        o1.connect(g1); g1.connect(ctx.destination);
        o1.start(base); o1.stop(base + 0.15);
        // 第二下 (輕)
        let o2 = ctx.createOscillator();
        let g2 = ctx.createGain();
        o2.type = 'sine'; o2.frequency.setValueAtTime(45, base + 0.2);
        g2.gain.setValueAtTime(0.6, base + 0.2);
        g2.gain.exponentialRampToValueAtTime(0.01, base + 0.32);
        o2.connect(g2); g2.connect(ctx.destination);
        o2.start(base + 0.2); o2.stop(base + 0.32);
    }
}

// 倒帶 — 快速下降掃頻
function playRewind() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let i = 0; i < 8; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        osc.type = 'square';
        let startFreq = 3000 - i * 300;
        osc.frequency.setValueAtTime(startFreq, t + i * 0.08);
        osc.frequency.exponentialRampToValueAtTime(startFreq * 0.3, t + i * 0.08 + 0.07);
        gain.gain.setValueAtTime(0.5, t + i * 0.08);
        gain.gain.setValueAtTime(0, t + i * 0.08 + 0.07);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(t + i * 0.08); osc.stop(t + i * 0.08 + 0.07);
    }
    // 背景噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.8, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let hp = ctx.createBiquadFilter();
    hp.type = 'highpass'; hp.frequency.setValueAtTime(2000, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.5, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.7);
    noise.connect(hp); hp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 史詩重擊 — 超重低音 + 金屬撞擊 + 殘響
function playEpicHit() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 超低頻衝擊
    let osc1 = ctx.createOscillator();
    let g1 = ctx.createGain();
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(80, t);
    osc1.frequency.exponentialRampToValueAtTime(25, t + 1.5);
    g1.gain.setValueAtTime(1.0, t);
    g1.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
    osc1.connect(g1); g1.connect(ctx.destination);
    osc1.start(); osc1.stop(t + 1.5);
    // 金屬層
    let osc2 = ctx.createOscillator();
    let g2 = ctx.createGain();
    osc2.type = 'square';
    osc2.frequency.setValueAtTime(800, t);
    osc2.frequency.exponentialRampToValueAtTime(200, t + 0.3);
    g2.gain.setValueAtTime(0.7, t);
    g2.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
    osc2.connect(g2); g2.connect(ctx.destination);
    osc2.start(); osc2.stop(t + 0.3);
    // 噪音爆破
    let buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(1.0, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 緊張上升 — 持續升頻製造壓迫感
function playRiser() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    let filter = ctx.createBiquadFilter();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(80, t);
    osc.frequency.exponentialRampToValueAtTime(2000, t + 2.5);
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(200, t);
    filter.frequency.exponentialRampToValueAtTime(5000, t + 2.5);
    filter.Q.setValueAtTime(10, t);
    gain.gain.setValueAtTime(0.2, t);
    gain.gain.linearRampToValueAtTime(1.0, t + 2.0);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 2.5);
    // 高頻噪音層越來越大
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let hp = ctx.createBiquadFilter();
    hp.type = 'highpass'; hp.frequency.setValueAtTime(3000, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0, t);
    nGain.gain.linearRampToValueAtTime(0.5, t + 2.3);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    noise.connect(hp); hp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 惡魔低語 — 極低頻 + 調變
function playDemonVoice() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 低沉嗡鳴
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    let tremolo = ctx.createOscillator();
    let tremoloGain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(70, t);
    osc.frequency.linearRampToValueAtTime(50, t + 0.5);
    osc.frequency.linearRampToValueAtTime(80, t + 1.0);
    osc.frequency.linearRampToValueAtTime(45, t + 2.0);
    // 顫抖效果
    tremolo.type = 'sine';
    tremolo.frequency.setValueAtTime(5, t);
    tremolo.frequency.linearRampToValueAtTime(12, t + 2.0);
    tremoloGain.gain.setValueAtTime(0.4, t);
    tremolo.connect(tremoloGain);
    tremoloGain.connect(gain.gain);
    gain.gain.setValueAtTime(0.7, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    let filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(300, t);
    filter.Q.setValueAtTime(8, t);
    osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
    osc.start(); tremolo.start();
    osc.stop(t + 2.0); tremolo.stop(t + 2.0);
    // 氣息噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let bp = ctx.createBiquadFilter();
    bp.type = 'bandpass'; bp.frequency.setValueAtTime(400, t); bp.Q.setValueAtTime(3, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.15, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    noise.connect(bp); bp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 駭客子彈時間 — 慢動作掃頻 + 金屬迴響
function playMatrixBullet() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 慢動作子彈飛過（掃頻）
    let osc = ctx.createOscillator();
    let gain = ctx.createGain();
    let filter = ctx.createBiquadFilter();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(2000, t);
    osc.frequency.exponentialRampToValueAtTime(100, t + 0.6);
    osc.frequency.exponentialRampToValueAtTime(80, t + 1.2);
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(2000, t);
    filter.frequency.exponentialRampToValueAtTime(100, t + 0.6);
    filter.Q.setValueAtTime(20, t);
    gain.gain.setValueAtTime(0.8, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 1.2);
    osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(t + 1.2);
    // 金屬迴響
    for (let i = 0; i < 5; i++) {
        let ping = ctx.createOscillator();
        let pg = ctx.createGain();
        ping.type = 'sine';
        ping.frequency.setValueAtTime(3000 + i * 500, t + 0.5 + i * 0.1);
        pg.gain.setValueAtTime(0.3, t + 0.5 + i * 0.1);
        pg.gain.exponentialRampToValueAtTime(0.01, t + 0.5 + i * 0.1 + 0.15);
        ping.connect(pg); pg.connect(ctx.destination);
        ping.start(t + 0.5 + i * 0.1); ping.stop(t + 0.5 + i * 0.1 + 0.15);
    }
}

// ========== SCREAM / ROAR SFX ==========

// 人類尖叫 — 用 formant 模擬人聲 "啊"
function playHumanScream() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 基頻（聲帶振動）
    let src = ctx.createOscillator();
    src.type = 'sawtooth';
    src.frequency.setValueAtTime(300, t);
    src.frequency.linearRampToValueAtTime(500, t + 0.2);
    src.frequency.linearRampToValueAtTime(450, t + 0.8);
    src.frequency.linearRampToValueAtTime(350, t + 1.5);
    // 加 vibrato
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(6, t);
    vib.frequency.linearRampToValueAtTime(10, t + 1.0);
    vibG.gain.setValueAtTime(15, t);
    vibG.gain.linearRampToValueAtTime(30, t + 1.0);
    vib.connect(vibG); vibG.connect(src.frequency);
    // Formant 1 (嘴型 "啊")
    let f1 = ctx.createBiquadFilter();
    f1.type = 'bandpass'; f1.frequency.setValueAtTime(800, t); f1.Q.setValueAtTime(8, t);
    // Formant 2
    let f2 = ctx.createBiquadFilter();
    f2.type = 'bandpass'; f2.frequency.setValueAtTime(1200, t); f2.Q.setValueAtTime(6, t);
    // Formant 3 (高頻尖銳)
    let f3 = ctx.createBiquadFilter();
    f3.type = 'bandpass'; f3.frequency.setValueAtTime(2800, t); f3.Q.setValueAtTime(5, t);
    let g1 = ctx.createGain(); g1.gain.setValueAtTime(1.0, t);
    let g2 = ctx.createGain(); g2.gain.setValueAtTime(0.7, t);
    let g3 = ctx.createGain(); g3.gain.setValueAtTime(0.5, t);
    let master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(1.0, t + 0.05);
    master.gain.setValueAtTime(1.0, t + 1.0);
    master.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
    src.connect(f1); f1.connect(g1); g1.connect(master);
    src.connect(f2); f2.connect(g2); g2.connect(master);
    src.connect(f3); f3.connect(g3); g3.connect(master);
    // 失真
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = x * 1.5 / (1 + Math.abs(x)); }
    dist.curve = curve;
    master.connect(dist); dist.connect(ctx.destination);
    src.start(); vib.start();
    src.stop(t + 1.5); vib.stop(t + 1.5);
    // 氣息噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 1.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nf = ctx.createBiquadFilter();
    nf.type = 'bandpass'; nf.frequency.setValueAtTime(2000, t); nf.Q.setValueAtTime(2, t);
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.2, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
    noise.connect(nf); nf.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 怪物吼叫 — 超低頻多層 + 失真
function playMonsterRoar() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 主吼叫
    let osc1 = ctx.createOscillator();
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(80, t);
    osc1.frequency.linearRampToValueAtTime(120, t + 0.3);
    osc1.frequency.linearRampToValueAtTime(60, t + 1.5);
    osc1.frequency.linearRampToValueAtTime(40, t + 2.0);
    // vibrato
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(4, t); vibG.gain.setValueAtTime(20, t);
    vib.connect(vibG); vibG.connect(osc1.frequency);
    // 第二層
    let osc2 = ctx.createOscillator();
    osc2.type = 'square';
    osc2.frequency.setValueAtTime(55, t);
    osc2.frequency.linearRampToValueAtTime(85, t + 0.3);
    osc2.frequency.linearRampToValueAtTime(35, t + 2.0);
    // 失真
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = Math.tanh(x * 3); }
    dist.curve = curve;
    let filter = ctx.createBiquadFilter();
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(500, t); filter.Q.setValueAtTime(5, t);
    let master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(1.0, t + 0.15);
    master.gain.setValueAtTime(1.0, t + 0.8);
    master.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    osc1.connect(dist); osc2.connect(dist);
    dist.connect(filter); filter.connect(master); master.connect(ctx.destination);
    osc1.start(); osc2.start(); vib.start();
    osc1.stop(t + 2.0); osc2.stop(t + 2.0); vib.stop(t + 2.0);
    // 噪音氣流
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.setValueAtTime(400, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.4, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    noise.connect(lp); lp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 女鬼尖叫 — 極高頻 + 顫抖
function playBanshee() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(600, t);
    osc.frequency.exponentialRampToValueAtTime(1500, t + 0.2);
    osc.frequency.linearRampToValueAtTime(1800, t + 0.5);
    osc.frequency.linearRampToValueAtTime(1200, t + 1.5);
    osc.frequency.linearRampToValueAtTime(800, t + 2.0);
    // 劇烈 vibrato
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(8, t);
    vib.frequency.linearRampToValueAtTime(14, t + 1.0);
    vibG.gain.setValueAtTime(40, t);
    vibG.gain.linearRampToValueAtTime(80, t + 1.0);
    vib.connect(vibG); vibG.connect(osc.frequency);
    // formant
    let f1 = ctx.createBiquadFilter();
    f1.type = 'bandpass'; f1.frequency.setValueAtTime(1000, t); f1.Q.setValueAtTime(6, t);
    let f2 = ctx.createBiquadFilter();
    f2.type = 'peaking'; f2.frequency.setValueAtTime(3000, t); f2.gain.setValueAtTime(10, t); f2.Q.setValueAtTime(3, t);
    let master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(0.9, t + 0.1);
    master.gain.setValueAtTime(0.9, t + 1.2);
    master.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    osc.connect(f1); f1.connect(f2); f2.connect(master); master.connect(ctx.destination);
    osc.start(); vib.start();
    osc.stop(t + 2.0); vib.stop(t + 2.0);
    // 氣息
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let hp = ctx.createBiquadFilter();
    hp.type = 'highpass'; hp.frequency.setValueAtTime(1500, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.3, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    noise.connect(hp); hp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 戰吼 — 從低到高爆發
function playWarCry() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(120, t);
    osc.frequency.linearRampToValueAtTime(250, t + 0.4);
    osc.frequency.linearRampToValueAtTime(350, t + 0.8);
    osc.frequency.linearRampToValueAtTime(300, t + 1.5);
    osc.frequency.linearRampToValueAtTime(150, t + 2.0);
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(5, t); vibG.gain.setValueAtTime(10, t);
    vibG.gain.linearRampToValueAtTime(25, t + 1.0);
    vib.connect(vibG); vibG.connect(osc.frequency);
    let f1 = ctx.createBiquadFilter();
    f1.type = 'bandpass'; f1.frequency.setValueAtTime(600, t);
    f1.frequency.linearRampToValueAtTime(1200, t + 0.8);
    f1.frequency.linearRampToValueAtTime(800, t + 2.0);
    f1.Q.setValueAtTime(4, t);
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = Math.tanh(x * 2); }
    dist.curve = curve;
    let master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(1.0, t + 0.3);
    master.gain.setValueAtTime(1.0, t + 1.2);
    master.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    osc.connect(f1); f1.connect(dist); dist.connect(master); master.connect(ctx.destination);
    osc.start(); vib.start();
    osc.stop(t + 2.0); vib.stop(t + 2.0);
    // 噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let bp = ctx.createBiquadFilter();
    bp.type = 'bandpass'; bp.frequency.setValueAtTime(1000, t); bp.Q.setValueAtTime(2, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0, t);
    nGain.gain.linearRampToValueAtTime(0.35, t + 0.3);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    noise.connect(bp); bp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 殭屍呻吟 — 低沉緩慢 + 斷續
function playZombie() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(90, t);
    osc.frequency.linearRampToValueAtTime(110, t + 0.5);
    osc.frequency.linearRampToValueAtTime(80, t + 1.0);
    osc.frequency.linearRampToValueAtTime(100, t + 1.5);
    osc.frequency.linearRampToValueAtTime(70, t + 2.5);
    // 慢 tremolo 製造斷續感
    let trem = ctx.createOscillator();
    let tremG = ctx.createGain();
    trem.frequency.setValueAtTime(3, t);
    tremG.gain.setValueAtTime(0.3, t);
    trem.connect(tremG);
    let f1 = ctx.createBiquadFilter();
    f1.type = 'bandpass'; f1.frequency.setValueAtTime(400, t); f1.Q.setValueAtTime(5, t);
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = Math.tanh(x * 2.5); }
    dist.curve = curve;
    let master = ctx.createGain();
    master.gain.setValueAtTime(0.7, t);
    master.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    tremG.connect(master.gain);
    osc.connect(f1); f1.connect(dist); dist.connect(master); master.connect(ctx.destination);
    osc.start(); trem.start();
    osc.stop(t + 2.5); trem.stop(t + 2.5);
    // 氣息
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.setValueAtTime(600, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.2, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    noise.connect(lp); lp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 野獸低吼 — 極低頻顫動 + 重失真
function playBeastGrowl() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(50, t);
    osc.frequency.linearRampToValueAtTime(70, t + 0.5);
    osc.frequency.linearRampToValueAtTime(45, t + 1.5);
    // 強 vibrato
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(7, t);
    vibG.gain.setValueAtTime(15, t);
    vib.connect(vibG); vibG.connect(osc.frequency);
    // 重失真
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.3); }
    dist.curve = curve;
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.setValueAtTime(350, t); lp.Q.setValueAtTime(8, t);
    let master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(1.0, t + 0.1);
    master.gain.setValueAtTime(1.0, t + 1.0);
    master.gain.exponentialRampToValueAtTime(0.01, t + 1.8);
    osc.connect(dist); dist.connect(lp); lp.connect(master); master.connect(ctx.destination);
    osc.start(); vib.start();
    osc.stop(t + 1.8); vib.stop(t + 1.8);
    // 低頻噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 1.8, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let nlp = ctx.createBiquadFilter();
    nlp.type = 'lowpass'; nlp.frequency.setValueAtTime(250, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.5, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 1.8);
    noise.connect(nlp); nlp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 鬼魂哀號 — 飄忽高低 + 迴音感
function playGhostWail() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    for (let layer = 0; layer < 3; layer++) {
        let osc = ctx.createOscillator();
        osc.type = 'sine';
        let base = 400 + layer * 150;
        osc.frequency.setValueAtTime(base, t + layer * 0.1);
        osc.frequency.linearRampToValueAtTime(base + 300, t + layer * 0.1 + 0.5);
        osc.frequency.linearRampToValueAtTime(base - 100, t + layer * 0.1 + 1.2);
        osc.frequency.linearRampToValueAtTime(base + 200, t + layer * 0.1 + 1.8);
        osc.frequency.linearRampToValueAtTime(base - 50, t + layer * 0.1 + 2.5);
        let vib = ctx.createOscillator();
        let vibG = ctx.createGain();
        vib.frequency.setValueAtTime(5 + layer * 2, t);
        vibG.gain.setValueAtTime(20 + layer * 10, t);
        vib.connect(vibG); vibG.connect(osc.frequency);
        let gain = ctx.createGain();
        gain.gain.setValueAtTime(0, t + layer * 0.1);
        gain.gain.linearRampToValueAtTime(0.5 - layer * 0.1, t + layer * 0.1 + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(); vib.start();
        osc.stop(t + 2.5); vib.stop(t + 2.5);
    }
    // 風聲
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let bp = ctx.createBiquadFilter();
    bp.type = 'bandpass'; bp.frequency.setValueAtTime(800, t); bp.Q.setValueAtTime(3, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.15, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    noise.connect(bp); bp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 龍吼 — 超低頻 + 高頻嘶叫 + 火焰噪音
function playDragonRoar() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 低頻主體
    let osc1 = ctx.createOscillator();
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(60, t);
    osc1.frequency.linearRampToValueAtTime(100, t + 0.3);
    osc1.frequency.linearRampToValueAtTime(50, t + 2.0);
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(5, t); vibG.gain.setValueAtTime(20, t);
    vib.connect(vibG); vibG.connect(osc1.frequency);
    // 高頻嘶叫層
    let osc2 = ctx.createOscillator();
    osc2.type = 'sawtooth';
    osc2.frequency.setValueAtTime(300, t + 0.2);
    osc2.frequency.linearRampToValueAtTime(600, t + 0.5);
    osc2.frequency.linearRampToValueAtTime(200, t + 2.0);
    let vib2 = ctx.createOscillator();
    let vibG2 = ctx.createGain();
    vib2.frequency.setValueAtTime(8, t); vibG2.gain.setValueAtTime(30, t);
    vib2.connect(vibG2); vibG2.connect(osc2.frequency);
    // 失真 + filter
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = Math.tanh(x * 4); }
    dist.curve = curve;
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.setValueAtTime(800, t); lp.Q.setValueAtTime(3, t);
    let g1 = ctx.createGain();
    g1.gain.setValueAtTime(0, t);
    g1.gain.linearRampToValueAtTime(1.0, t + 0.15);
    g1.gain.setValueAtTime(1.0, t + 1.0);
    g1.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    let g2 = ctx.createGain();
    g2.gain.setValueAtTime(0, t);
    g2.gain.linearRampToValueAtTime(0.5, t + 0.3);
    g2.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
    osc1.connect(dist); dist.connect(lp); lp.connect(g1); g1.connect(ctx.destination);
    osc2.connect(g2); g2.connect(ctx.destination);
    osc1.start(); osc2.start(); vib.start(); vib2.start();
    osc1.stop(t + 2.5); osc2.stop(t + 2.5); vib.stop(t + 2.5); vib2.stop(t + 2.5);
    // 火焰噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let bp = ctx.createBiquadFilter();
    bp.type = 'bandpass'; bp.frequency.setValueAtTime(1500, t);
    bp.frequency.linearRampToValueAtTime(500, t + 2.0);
    bp.Q.setValueAtTime(2, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0, t);
    nGain.gain.linearRampToValueAtTime(0.5, t + 0.3);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    noise.connect(bp); bp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 恐慌尖叫 — 快速上升 + 劇烈抖動
function playPanicScream() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    let osc = ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(250, t);
    osc.frequency.exponentialRampToValueAtTime(900, t + 0.15);
    osc.frequency.setValueAtTime(900, t + 0.5);
    osc.frequency.linearRampToValueAtTime(700, t + 1.0);
    // 超快 vibrato
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(12, t);
    vib.frequency.linearRampToValueAtTime(20, t + 0.5);
    vibG.gain.setValueAtTime(30, t);
    vibG.gain.linearRampToValueAtTime(60, t + 0.5);
    vib.connect(vibG); vibG.connect(osc.frequency);
    let f1 = ctx.createBiquadFilter();
    f1.type = 'bandpass'; f1.frequency.setValueAtTime(1200, t); f1.Q.setValueAtTime(5, t);
    let f2 = ctx.createBiquadFilter();
    f2.type = 'peaking'; f2.frequency.setValueAtTime(3500, t); f2.gain.setValueAtTime(12, t);
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = Math.tanh(x * 2); }
    dist.curve = curve;
    let master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(1.0, t + 0.05);
    master.gain.setValueAtTime(1.0, t + 0.7);
    master.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
    osc.connect(f1); f1.connect(f2); f2.connect(dist); dist.connect(master); master.connect(ctx.destination);
    osc.start(); vib.start();
    osc.stop(t + 1.0); vib.stop(t + 1.0);
    // 噪音
    let buf = ctx.createBuffer(1, ctx.sampleRate * 1, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    let hp = ctx.createBiquadFilter();
    hp.type = 'highpass'; hp.frequency.setValueAtTime(2000, t);
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.3, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
    noise.connect(hp); hp.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

// 惡魔嘶吼 — 雙聲道不和諧 + 重失真 + 噪音
function playDemonScream() {
    let ctx = new AudioContext();
    let t = ctx.currentTime;
    // 低層
    let osc1 = ctx.createOscillator();
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(100, t);
    osc1.frequency.linearRampToValueAtTime(180, t + 0.3);
    osc1.frequency.linearRampToValueAtTime(80, t + 2.0);
    // 高層（不和諧）
    let osc2 = ctx.createOscillator();
    osc2.type = 'sawtooth';
    osc2.frequency.setValueAtTime(666, t);
    osc2.frequency.linearRampToValueAtTime(900, t + 0.3);
    osc2.frequency.linearRampToValueAtTime(500, t + 2.0);
    // vibrato
    let vib = ctx.createOscillator();
    let vibG = ctx.createGain();
    vib.frequency.setValueAtTime(6, t);
    vib.frequency.linearRampToValueAtTime(15, t + 1.5);
    vibG.gain.setValueAtTime(20, t);
    vibG.gain.linearRampToValueAtTime(50, t + 1.5);
    vib.connect(vibG); vibG.connect(osc1.frequency);
    let vib2 = ctx.createOscillator();
    let vibG2 = ctx.createGain();
    vib2.frequency.setValueAtTime(7, t); vibG2.gain.setValueAtTime(40, t);
    vib2.connect(vibG2); vibG2.connect(osc2.frequency);
    // 重失真
    let dist = ctx.createWaveShaper();
    let curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { let x = (i / 128) - 1; curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.2); }
    dist.curve = curve;
    let lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.setValueAtTime(2000, t); lp.Q.setValueAtTime(3, t);
    let master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(1.0, t + 0.1);
    master.gain.setValueAtTime(1.0, t + 1.0);
    master.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    let g2 = ctx.createGain();
    g2.gain.setValueAtTime(0.4, t);
    osc1.connect(dist); osc2.connect(g2); g2.connect(dist);
    dist.connect(lp); lp.connect(master); master.connect(ctx.destination);
    osc1.start(); osc2.start(); vib.start(); vib2.start();
    osc1.stop(t + 2.5); osc2.stop(t + 2.5); vib.stop(t + 2.5); vib2.stop(t + 2.5);
    // 噪音地獄
    let buf = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
    let data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    let noise = ctx.createBufferSource();
    let nGain = ctx.createGain();
    noise.buffer = buf;
    nGain.gain.setValueAtTime(0.3, t);
    nGain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);
    noise.connect(nGain); nGain.connect(ctx.destination);
    noise.start();
}

const AC = window.__AC || (window.__AC = new (window.AudioContext||window.webkitAudioContext)());
const _t = () => { if (AC.state === "suspended") AC.resume(); return AC.currentTime; };
const _env = (g, t, a, d, peak=0.9) => {
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(peak, t + a);
  g.gain.exponentialRampToValueAtTime(0.0001, t + a + d);
};
const _noise = (dur) => {
  const sr = AC.sampleRate, len = (sr * dur) | 0;
  const b = AC.createBuffer(1, len, sr), data = b.getChannelData(0);
  for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1);
  const s = AC.createBufferSource(); s.buffer = b; return s;
};
const _dist = (amt=2.5) => {
  const ws = AC.createWaveShaper(), n = 256, c = new Float32Array(n);
  for (let i=0;i<n;i++){ const x=i/(n-1)*2-1; c[i]=Math.tanh(x*amt); }
  ws.curve = c; return ws;
};

/* 1) CYBER KATANA (超乾淨賽博斬擊) */
function playCyberKatana(){
  const t=_t();
  const o=AC.createOscillator(), g=AC.createGain(), bp=AC.createBiquadFilter(), ws=_dist(3.2);
  o.type="sawtooth";
  o.frequency.setValueAtTime(1900,t);
  o.frequency.exponentialRampToValueAtTime(230,t+0.13);
  o.detune.setValueAtTime(-25,t);
  o.detune.linearRampToValueAtTime(40,t+0.06);
  bp.type="bandpass"; bp.frequency.setValueAtTime(1600,t); bp.Q.value=14;
  _env(g,t,0.002,0.20,0.65);
  o.connect(bp); bp.connect(ws); ws.connect(g); g.connect(AC.destination);
  o.start(t); o.stop(t+0.22);

  const n=_noise(0.10), ng=AC.createGain(), hp=AC.createBiquadFilter();
  hp.type="highpass"; hp.frequency.setValueAtTime(5200,t);
  ng.gain.setValueAtTime(0.0001,t);
  ng.gain.exponentialRampToValueAtTime(0.35,t+0.006);
  ng.gain.exponentialRampToValueAtTime(0.0001,t+0.10);
  n.connect(hp); hp.connect(ng); ng.connect(AC.destination);
  n.start(t); n.stop(t+0.10);
}

/* 2) PORTAL POP (傳送門彈出 + 尾巴) */
function playPortalPop(){
  const t=_t();
  const o=AC.createOscillator(), g=AC.createGain(), lp=AC.createBiquadFilter();
  const d=AC.createDelay(1), fb=AC.createGain(), wet=AC.createGain();

  o.type="sine";
  o.frequency.setValueAtTime(220,t);
  o.frequency.exponentialRampToValueAtTime(3200,t+0.22);
  lp.type="lowpass";
  lp.frequency.setValueAtTime(400,t);
  lp.frequency.exponentialRampToValueAtTime(9000,t+0.22);
  _env(g,t,0.003,0.28,0.55);

  d.delayTime.setValueAtTime(0.085,t);
  fb.gain.setValueAtTime(0.38,t);
  wet.gain.setValueAtTime(0.55,t);
  d.connect(fb); fb.connect(d);

  o.connect(lp); lp.connect(g);
  g.connect(AC.destination);
  g.connect(d); d.connect(wet); wet.connect(AC.destination);

  // whoosh
  const n=_noise(0.18), ng=AC.createGain(), bp=AC.createBiquadFilter();
  bp.type="bandpass"; bp.frequency.setValueAtTime(1200,t); bp.Q.value=1.2;
  ng.gain.setValueAtTime(0.0001,t);
  ng.gain.exponentialRampToValueAtTime(0.25,t+0.02);
  ng.gain.exponentialRampToValueAtTime(0.0001,t+0.18);
  n.connect(bp); bp.connect(ng); ng.connect(AC.destination);
  n.start(t); n.stop(t+0.18);

  o.start(t); o.stop(t+0.35);
}

/* 3) NEON CONFIRM (霓虹 UI 確認音：乾淨又高級) */
function playNeonConfirm(){
  const t=_t();
  const notes=[880,1320,1760]; // A5 + E6 + A6
  for(let i=0;i<notes.length;i++){
    const o=AC.createOscillator(), g=AC.createGain(), hp=AC.createBiquadFilter();
    o.type="triangle";
    o.frequency.setValueAtTime(notes[i], t+i*0.045);
    hp.type="highpass"; hp.frequency.setValueAtTime(900,t);
    g.gain.setValueAtTime(0.0001, t+i*0.045);
    g.gain.exponentialRampToValueAtTime(0.35, t+i*0.045+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t+i*0.045+0.12);
    o.connect(hp); hp.connect(g); g.connect(AC.destination);
    o.start(t+i*0.045); o.stop(t+i*0.045+0.13);
  }
  // little sparkle
  const o2=AC.createOscillator(), g2=AC.createGain();
  o2.type="sine";
  o2.frequency.setValueAtTime(4200,t+0.02);
  o2.frequency.exponentialRampToValueAtTime(1600,t+0.12);
  _env(g2,t+0.02,0.002,0.14,0.18);
  o2.connect(g2); g2.connect(AC.destination);
  o2.start(t+0.02); o2.stop(t+0.18);
}

/* 4) BOSS SPAWN (Boss 出場：低頻下墜 + 金屬衝擊) */
function playBossSpawn(){
  const t=_t();
  // sub drop
  const sub=AC.createOscillator(), sg=AC.createGain();
  sub.type="sine";
  sub.frequency.setValueAtTime(110,t);
  sub.frequency.exponentialRampToValueAtTime(28,t+0.75);
  _env(sg,t,0.01,0.95,0.95);
  sub.connect(sg); sg.connect(AC.destination);
  sub.start(t); sub.stop(t+1.0);

  // metallic hit
  const o=AC.createOscillator(), g=AC.createGain(), bp=AC.createBiquadFilter(), ws=_dist(4.0);
  o.type="square";
  o.frequency.setValueAtTime(900,t+0.06);
  o.frequency.exponentialRampToValueAtTime(180,t+0.26);
  bp.type="bandpass"; bp.frequency.setValueAtTime(1400,t); bp.Q.value=10;
  _env(g,t+0.06,0.002,0.28,0.55);
  o.connect(bp); bp.connect(ws); ws.connect(g); g.connect(AC.destination);
  o.start(t+0.06); o.stop(t+0.36);

  // crack noise
  const n=_noise(0.22), ng=AC.createGain(), lp=AC.createBiquadFilter();
  lp.type="lowpass"; lp.frequency.setValueAtTime(2400,t);
  ng.gain.setValueAtTime(0.0001,t+0.05);
  ng.gain.exponentialRampToValueAtTime(0.55,t+0.06);
  ng.gain.exponentialRampToValueAtTime(0.0001,t+0.27);
  n.connect(lp); lp.connect(ng); ng.connect(AC.destination);
  n.start(t+0.05); n.stop(t+0.27);
}

/* 5) TIME FREEZE (時間凍結：tape-stop + 抖動停住) */
function playTimeFreeze(){
  const t=_t();
  const o=AC.createOscillator(), g=AC.createGain(), lp=AC.createBiquadFilter();
  o.type="sawtooth";
  o.frequency.setValueAtTime(1400,t);
  o.frequency.exponentialRampToValueAtTime(70,t+0.75);
  lp.type="lowpass";
  lp.frequency.setValueAtTime(9000,t);
  lp.frequency.exponentialRampToValueAtTime(400,t+0.75);

  // stutter gate
  for(let i=0;i<18;i++){
    const tt=t+i*0.04;
    const amp=((i%2)?0.07:0.85) * Math.exp(-i/14);
    g.gain.setValueAtTime(amp, tt);
  }
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.80);

  o.connect(lp); lp.connect(g); g.connect(AC.destination);
  o.start(t); o.stop(t+0.85);

  // icy hiss
  const n=_noise(0.35), ng=AC.createGain(), hp=AC.createBiquadFilter();
  hp.type="highpass"; hp.frequency.setValueAtTime(3500,t);
  ng.gain.setValueAtTime(0.0001,t);
  ng.gain.exponentialRampToValueAtTime(0.18,t+0.05);
  ng.gain.exponentialRampToValueAtTime(0.0001,t+0.35);
  n.connect(hp); hp.connect(ng); ng.connect(AC.destination);
  n.start(t); n.stop(t+0.35);
}

/* 6) DATA CORRUPT (超酷數位崩壞：glitch + 啪的一下) */
function playDataCorrupt(){
  const t=_t();
  // glitch bursts
  for(let i=0;i<14;i++){
    const o=AC.createOscillator(), g=AC.createGain(), ws=_dist(3.5);
    const start=t+i*0.035, dur=0.012+(Math.random()*0.03);
    o.type=(Math.random()<0.5)?"square":"sawtooth";
    o.frequency.setValueAtTime(120+Math.random()*2600, start);
    g.gain.setValueAtTime(0.0001, start);
    g.gain.exponentialRampToValueAtTime(0.35, start+0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, start+dur);
    o.connect(ws); ws.connect(g); g.connect(AC.destination);
    o.start(start); o.stop(start+dur+0.01);
  }
  // “pop” hit
  const o2=AC.createOscillator(), g2=AC.createGain();
  o2.type="sine";
  o2.frequency.setValueAtTime(90,t+0.05);
  o2.frequency.exponentialRampToValueAtTime(35,t+0.25);
  _env(g2,t+0.05,0.004,0.30,0.75);
  o2.connect(g2); g2.connect(AC.destination);
  o2.start(t+0.05); o2.stop(t+0.38);

  const n=_noise(0.18), ng=AC.createGain(), bp=AC.createBiquadFilter();
  bp.type="bandpass"; bp.frequency.setValueAtTime(2200,t); bp.Q.value=2.2;
  ng.gain.setValueAtTime(0.0001,t+0.02);
  ng.gain.exponentialRampToValueAtTime(0.35,t+0.03);
  ng.gain.exponentialRampToValueAtTime(0.0001,t+0.20);
  n.connect(bp); bp.connect(ng); ng.connect(AC.destination);
  n.start(t+0.02); n.stop(t+0.20);
}
/* ===== ULTRA SFX PACK (paste at end of your <script>) ===== */
/* Shared AudioContext + limiter (sounds stronger but safer) */
const SFX = (() => {
  const AC = window.__SFX_AC || (window.__SFX_AC = new (window.AudioContext||window.webkitAudioContext)());
  const master = window.__SFX_MASTER || (() => {
    const g = AC.createGain();
    const comp = AC.createDynamicsCompressor();
    comp.threshold.setValueAtTime(-18, AC.currentTime);
    comp.knee.setValueAtTime(28, AC.currentTime);
    comp.ratio.setValueAtTime(12, AC.currentTime);
    comp.attack.setValueAtTime(0.003, AC.currentTime);
    comp.release.setValueAtTime(0.25, AC.currentTime);
    g.gain.value = 0.85; // overall volume (0.6~1.0)
    g.connect(comp); comp.connect(AC.destination);
    return { g, comp };
  })();
  window.__SFX_MASTER = master;

  const now = () => { if (AC.state === "suspended") AC.resume(); return AC.currentTime; };

  const env = (gainNode, t, a, d, peak=1.0) => {
    const g = gainNode.gain;
    g.cancelScheduledValues(t);
    g.setValueAtTime(0.0001, t);
    g.exponentialRampToValueAtTime(Math.max(0.0002, peak), t + a);
    g.exponentialRampToValueAtTime(0.0001, t + a + d);
  };

  const noise = (dur) => {
    const sr = AC.sampleRate, len = (sr * dur) | 0;
    const b = AC.createBuffer(1, len, sr);
    const d = b.getChannelData(0);
    for (let i=0;i<len;i++) d[i] = (Math.random()*2-1);
    const s = AC.createBufferSource(); s.buffer = b;
    return s;
  };

  const dist = (amt=3.0) => {
    const ws = AC.createWaveShaper();
    const n = 512, c = new Float32Array(n);
    for (let i=0;i<n;i++) {
      const x = (i/(n-1))*2 - 1;
      c[i] = Math.tanh(x * amt);
    }
    ws.curve = c;
    return ws;
  };

  // Small “space” tail: feedback delay + lowpass (cheap reverb-ish)
  const space = (input, t, wet=0.28, time=0.11, fbAmt=0.62, lpHz=2400) => {
    const d1 = AC.createDelay(1.0);
    const fb = AC.createGain();
    const lp = AC.createBiquadFilter();
    const wg = AC.createGain();
    d1.delayTime.setValueAtTime(time, t);
    fb.gain.setValueAtTime(fbAmt, t);
    lp.type = "lowpass"; lp.frequency.setValueAtTime(lpHz, t);
    wg.gain.setValueAtTime(wet, t);

    input.connect(d1);
    d1.connect(lp); lp.connect(fb); fb.connect(d1);
    lp.connect(wg); wg.connect(master.g);
  };

  // Autopan: stereo panner driven by LFO
  const autopan = (input, t, rate=7.0, depth=0.9, dur=1.0) => {
    const p = AC.createStereoPanner();
    const lfo = AC.createOscillator();
    const lfoG = AC.createGain();
    lfo.type = "sine";
    lfo.frequency.setValueAtTime(rate, t);
    lfoG.gain.setValueAtTime(depth, t);
    lfo.connect(lfoG); lfoG.connect(p.pan);
    input.connect(p); p.connect(master.g);
    lfo.start(t); lfo.stop(t + dur + 0.05);
    return p;
  };

  /* 1) WORMHOLE WARP (超新鮮：傳送門旋轉 + 立體空間尾音) */
  function playWormhole(){
    const t = now();

    const g = AC.createGain(); env(g, t, 0.01, 1.15, 0.9);
    const bp = AC.createBiquadFilter();
    bp.type = "bandpass";
    bp.Q.setValueAtTime(1.2, t);
    bp.frequency.setValueAtTime(280, t);
    bp.frequency.exponentialRampToValueAtTime(5200, t + 0.75);
    bp.frequency.exponentialRampToValueAtTime(700, t + 1.15);

    const o1 = AC.createOscillator();
    const o2 = AC.createOscillator();
    o1.type = "sawtooth"; o2.type = "triangle";
    o1.frequency.setValueAtTime(160, t);
    o1.frequency.exponentialRampToValueAtTime(4200, t + 0.8);
    o1.frequency.exponentialRampToValueAtTime(220, t + 1.15);
    o2.frequency.setValueAtTime(164, t);
    o2.frequency.exponentialRampToValueAtTime(3800, t + 0.8);
    o2.frequency.exponentialRampToValueAtTime(240, t + 1.15);
    o1.detune.setValueAtTime(-10, t);
    o2.detune.setValueAtTime( +11, t);

    const n = noise(0.45);
    const ng = AC.createGain(); env(ng, t+0.05, 0.01, 0.35, 0.35);
    const hp = AC.createBiquadFilter();
    hp.type = "highpass"; hp.frequency.setValueAtTime(900, t);

    // “spin” shimmer: fast pitch wobble
    const wob = AC.createOscillator();
    const wobG = AC.createGain();
    wob.type = "sine"; wob.frequency.setValueAtTime(11, t);
    wobG.gain.setValueAtTime(30, t);
    wob.connect(wobG); wobG.connect(o1.frequency); wobG.connect(o2.frequency);

    const pre = AC.createGain(); pre.gain.setValueAtTime(0.75, t);

    o1.connect(pre); o2.connect(pre);
    pre.connect(bp); bp.connect(g);

    n.connect(hp); hp.connect(ng); ng.connect(g);

    // stereo + space tail
    const p = autopan(g, t, 8.5, 0.95, 1.2);
    space(p, t, 0.35, 0.095, 0.68, 2600);

    g.connect(master.g);

    o1.start(t); o2.start(t); wob.start(t); n.start(t);
    o1.stop(t+1.25); o2.stop(t+1.25); wob.stop(t+1.25); n.stop(t+0.5);
  }

  /* 2) ANTIMATTER SLAM (超爽重擊：低頻墜落 + 金屬核心 + 高頻裂響 + 殘響) */
  function playAntimatterSlam(){
    const t = now();

    // SUB DROP
    const sub = AC.createOscillator();
    const sg = AC.createGain();
    sub.type = "sine";
    sub.frequency.setValueAtTime(95, t);
    sub.frequency.exponentialRampToValueAtTime(24, t + 0.95);
    env(sg, t, 0.01, 1.25, 0.95);
    sub.connect(sg);

    // METAL CORE (FM-ish)
    const car = AC.createOscillator();
    const mod = AC.createOscillator();
    const modG = AC.createGain();
    car.type = "sawtooth";
    car.frequency.setValueAtTime(220, t);
    car.frequency.exponentialRampToValueAtTime(60, t + 0.6);
    mod.type = "sine";
    mod.frequency.setValueAtTime(420, t);
    mod.frequency.exponentialRampToValueAtTime(80, t + 0.6);
    modG.gain.setValueAtTime(420, t);
    modG.gain.exponentialRampToValueAtTime(40, t + 0.6);
    mod.connect(modG); modG.connect(car.frequency);

    const mg = AC.createGain(); env(mg, t, 0.002, 0.75, 0.65);

    const ws = dist(3.6);
    const lp = AC.createBiquadFilter();
    lp.type="lowpass"; lp.frequency.setValueAtTime(2200, t);

    car.connect(ws); ws.connect(lp); lp.connect(mg);

    // CRACK (noise snap)
    const n = noise(0.12);
    const ng = AC.createGain(); env(ng, t, 0.001, 0.18, 0.65);
    const hp = AC.createBiquadFilter();
    hp.type="highpass"; hp.frequency.setValueAtTime(2800, t);
    const bp = AC.createBiquadFilter();
    bp.type="bandpass"; bp.frequency.setValueAtTime(5200, t); bp.Q.value = 3.5;
    n.connect(hp); hp.connect(bp); bp.connect(ng);

    // MIX BUS
    const mix = AC.createGain(); mix.gain.setValueAtTime(0.95, t);
    sg.connect(mix); mg.connect(mix); ng.connect(mix);

    // stereo movement + space tail
    const p = autopan(mix, t, 5.2, 0.65, 1.3);
    space(p, t, 0.42, 0.12, 0.66, 1800);
    mix.connect(master.g);

    sub.start(t); sub.stop(t+1.35);
    car.start(t); car.stop(t+0.95);
    mod.start(t); mod.stop(t+0.95);
    n.start(t); n.stop(t+0.12);
  }

  /* 3) NEURAL SNAP (耳目一新：像 AI/腦機介面「啪」一下的賽博提示音) */
  function playNeuralSnap(){
    const t = now();

    // Clicky transient
    const n = noise(0.06);
    const ng = AC.createGain(); env(ng, t, 0.001, 0.09, 0.55);
    const bp = AC.createBiquadFilter();
    bp.type="bandpass";
    bp.Q.setValueAtTime(12, t);
    bp.frequency.setValueAtTime(6500, t);
    bp.frequency.exponentialRampToValueAtTime(1200, t+0.06);
    n.connect(bp); bp.connect(ng);

    // Metallic “neural” tone: ring-mod + pitch bend
    const car = AC.createOscillator();
    const mod = AC.createOscillator();
    const ring = AC.createGain();
    const offset = AC.createConstantSource();
    const tg = AC.createGain();

    car.type="square";
    car.frequency.setValueAtTime(3200, t);
    car.frequency.exponentialRampToValueAtTime(420, t+0.12);

    mod.type="sine";
    mod.frequency.setValueAtTime(90, t);
    mod.frequency.exponentialRampToValueAtTime(22, t+0.12);

    // ring modulation (mod -> ring.gain), plus offset so it doesn't fully cancel
    offset.offset.setValueAtTime(0.55, t);
    mod.connect(ring.gain);
    offset.connect(ring.gain);

    env(tg, t, 0.002, 0.22, 0.55);

    car.connect(ring); ring.connect(tg);

    // tiny echo sparkle
    const d = AC.createDelay(1);
    const fb = AC.createGain();
    const wet = AC.createGain();
    d.delayTime.setValueAtTime(0.07, t);
    fb.gain.setValueAtTime(0.28, t);
    wet.gain.setValueAtTime(0.22, t);
    tg.connect(d); d.connect(fb); fb.connect(d);
    d.connect(wet);

    const mix = AC.createGain(); mix.gain.setValueAtTime(0.95, t);
    ng.connect(mix); tg.connect(mix); wet.connect(mix);
    autopan(mix, t, 10.5, 0.85, 0.35);
    mix.connect(master.g);

    n.start(t); n.stop(t+0.06);
    car.start(t); car.stop(t+0.26);
    mod.start(t); mod.stop(t+0.26);
    offset.start(t); offset.stop(t+0.26);
  }

  /* 4) QUANTUM GLITTER (很有記憶點：玻璃碎鑽 + 立體閃爍尾音) */
  function playQuantumGlitter(){
    const t = now();
    const mix = AC.createGain(); mix.gain.setValueAtTime(0.9, t);

    // micro-arp pings
    const freqs = [1760, 2093, 2637, 3136, 4186];
    for (let i=0;i<freqs.length;i++){
      const tt = t + i*0.045;
      const o = AC.createOscillator();
      const g = AC.createGain();
      const hp = AC.createBiquadFilter();
      hp.type="highpass"; hp.frequency.setValueAtTime(1200, tt);

      o.type="triangle";
      o.frequency.setValueAtTime(freqs[i], tt);
      o.detune.setValueAtTime((i%2? -12: +9), tt);

      env(g, tt, 0.002, 0.12, 0.32);
      o.connect(hp); hp.connect(g); g.connect(mix);
      o.start(tt); o.stop(tt+0.16);
    }

    // shimmer sweep
    const sh = AC.createOscillator();
    const sg = AC.createGain(); env(sg, t+0.05, 0.01, 0.35, 0.18);
    sh.type="sine";
    sh.frequency.setValueAtTime(5200, t+0.05);
    sh.frequency.exponentialRampToValueAtTime(12000, t+0.25);
    sh.frequency.exponentialRampToValueAtTime(6800, t+0.4);
    sh.connect(sg); sg.connect(mix);

    const p = autopan(mix, t, 12.0, 0.95, 0.8);
    space(p, t, 0.45, 0.083, 0.72, 3200);
    mix.connect(master.g);

    sh.start(t+0.05); sh.stop(t+0.45);
  }

  return { playWormhole, playAntimatterSlam, playNeuralSnap, playQuantumGlitter };
})();

/* Expose functions with your naming style */
function playWormhole(){ SFX.playWormhole(); }
function playAntimatterSlam(){ SFX.playAntimatterSlam(); }
function playNeuralSnap(){ SFX.playNeuralSnap(); }
function playQuantumGlitter(){ SFX.playQuantumGlitter(); }





</script>
</body>
</html>
