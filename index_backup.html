<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; }
        #start-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; font-size: 20px; background: #0f0; color: #000; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ui">Mic Level: <span id="mic-val">0</span> | Steps: <span id="steps">0</span></div>
    <button id="start-btn">Start Game (Allow Mic)</button>
    <canvas id="gameCanvas"></canvas>

<script>
// --- 1. åˆå§‹åŒ–è¨­å®š ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiMic = document.getElementById('mic-val');
let mapWidth = 100;
let mapHeight = 100;
let tileSize = 20; // æ¯å€‹æ ¼å­çš„åƒç´ å¤§å°
let map = []; // 0=Wall, 1=Floor
let player = { x: 1, y: 1, dirX: 0, dirY: 0 }; // dirç´€éŒ„æœ€å¾Œç§»å‹•æ–¹å‘
let goal = { x: 0, y: 0 };
let micLevel = 0; // é‡åŒ–å¾Œçš„éŸ³é‡ 0-10
let audioContext, analyser, dataArray;
let camera = { x: 0, y: 0 }; // é¡é ­ä½ç½®

// --- 2. åœ°åœ–ç”Ÿæˆ (ç”¨ç¨‹å¼ç”Ÿæˆä»£æ›¿ Hardcode ä»¥ç¯€çœç©ºé–“) ---
// å¦‚æœçœŸçš„è¦ Hardcode 100*100 arrayï¼Œæœƒä½” 20KB æ–‡å­—é‡ï¼Œæœƒçˆ†æ‰é™åˆ¶ã€‚
// é€™è£¡ç”¨ç°¡å–®çš„æ¼”ç®—æ³•ç”Ÿæˆä¸€å€‹åœç‰†åœ°åœ–
function generateMap() {
    map = [];
    for (let y = 0; y < mapHeight; y++) {
        let row = [];
        for (let x = 0; x < mapWidth; x++) {
            // é‚Šç·£æ˜¯ç‰†(0)ï¼Œéš¨æ©Ÿç”Ÿæˆéšœç¤™ç‰©
            if (x === 0 || x === mapWidth - 1 || y === 0 || y === mapHeight - 1 || Math.random() < 0.2) {
                row.push(0); 
            } else {
                row.push(1);
            }
        }
        map.push(row);
    }
    // ç¢ºä¿èµ·é»æ˜¯ç©ºçš„
    map[1][1] = 1;
    player.x = 1; player.y = 1;
    
    // ç”Ÿæˆçµ‚é» (ç°¡å–®æ‰¾ä¸€å€‹ä¸æ˜¯ç‰†çš„åœ°æ–¹)
    while(true) {
        let gx = Math.floor(Math.random() * mapWidth);
        let gy = Math.floor(Math.random() * mapHeight);
        if (map[gy][gx] === 1 && (gx > 10 || gy > 10)) { // é›¢èµ·é»é ä¸€é»
            goal = {x: gx, y: gy};
            break;
        }
    }
}

// --- 3. éº¥å…‹é¢¨èˆ‡éŸ³è¨Šè™•ç† ---
async function initAudio() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        document.getElementById('start-btn').style.display = 'none';
        gameLoop();
    } catch (e) {
        alert("Microphone access denied! Game needs mic.");
    }
}

function updateMic() {
    if (!analyser) return;
    analyser.getByteFrequencyData(dataArray);
    
    // è¨ˆç®—å¹³å‡éŸ³é‡
    let sum = 0;
    for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
    let avg = sum / dataArray.length;
    
    // é‡åŒ–æˆ 0 ~ 10 (ä½ å¯ä»¥èª¿æ•´é™¤æ•¸ 25 ä¾†æ”¹è®Šéˆæ•åº¦)
    micLevel = Math.min(10, Math.floor(avg / 10)); 
    uiMic.innerText = micLevel;
}

// --- 4. éŠæˆ²é‚è¼¯èˆ‡æ§åˆ¶ ---
function move(dx, dy) {
    let newX = player.x + dx;
    let newY = player.y + dy;
    
    // ç¢°æ’æª¢æ¸¬ï¼šå¦‚æœæ˜¯åœ°æ¿(1)æ‰èƒ½èµ°
    if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight && map[newY][newX] === 1) {
        player.x = newX;
        player.y = newY;
    }
    // æ›´æ–°é¢æœæ–¹å‘ (ç”¨æ–¼ç…§æ˜)
    if (dx !== 0 || dy !== 0) {
        player.dirX = dx;
        player.dirY = dy;
    }
    
    // å‹åˆ©åˆ¤å®š
    if (player.x === goal.x && player.y === goal.y) {
        alert("You Win! Refresh to restart.");
        location.reload();
    }
}

// éµç›¤æ§åˆ¶ (Desktop)
window.addEventListener('keydown', (e) => {
    if (e.key === 'w' || e.key === 'ArrowUp') move(0, -1);
    if (e.key === 's' || e.key === 'ArrowDown') move(0, 1);
    if (e.key === 'a' || e.key === 'ArrowLeft') move(-1, 0);
    if (e.key === 'd' || e.key === 'ArrowRight') move(1, 0);
});

// è§¸æ§æ§åˆ¶ (Mobile) - é»æ“Šè¢å¹•é‚Šç·£ç§»å‹•
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const cx = window.innerWidth / 2;
    const cy = window.innerHeight / 2;
    const tx = touch.clientX;
    const ty = touch.clientY;
    
    // ç°¡å–®çš„å››å‘åˆ¤å®š
    if (Math.abs(tx - cx) > Math.abs(ty - cy)) {
        if (tx < cx) move(-1, 0); // Left
        else move(1, 0);          // Right
    } else {
        if (ty < cy) move(0, -1); // Up
        else move(0, 1);          // Down
    }
}, {passive: false});

// --- 5. æ¸²æŸ“è¿´åœˆ ---
function draw() {
    // èª¿æ•´ Canvas å¤§å°
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // è¨ˆç®—é¡é ­ä½ç½® (è®“ç©å®¶ä¿æŒåœ¨ä¸­å¿ƒ)
    let screenTilesX = Math.ceil(canvas.width / tileSize);
    let screenTilesY = Math.ceil(canvas.height / tileSize);
    let offsetX = (canvas.width / 2) - (player.x * tileSize) - (tileSize / 2);
    let offsetY = (canvas.height / 2) - (player.y * tileSize) - (tileSize / 2);

    // æ¸…ç©ºèƒŒæ™¯
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ç¹ªè£½åœ°åœ– (åªç¹ªè£½è¦–é‡å…§çš„ä»¥ç¯€çœæ•ˆèƒ½)
    // é€™è£¡æˆ‘å€‘ç‚ºäº† Demo ç°¡å–®ï¼Œå…ˆç¹ªè£½å¯è¦‹å€åŸŸ
    let startCol = Math.floor(-offsetX / tileSize);
    let endCol = startCol + screenTilesX + 1;
    let startRow = Math.floor(-offsetY / tileSize);
    let endRow = startRow + screenTilesY + 1;

    for (let y = startRow; y < endRow; y++) {
        for (let x = startCol; x < endCol; x++) {
            if (y >= 0 && y < mapHeight && x >= 0 && x < mapWidth) {
                let tileX = x * tileSize + offsetX;
                let tileY = y * tileSize + offsetY;
                
                // ç‰†å£ (0)
                if (map[y][x] === 0) {
                    ctx.fillStyle = '#444'; // ç°è‰²ç‰†å£
                    ctx.fillRect(tileX, tileY, tileSize, tileSize);
                } else {
                    // åœ°æ¿ (1) - ç•«æ ¼ç·š
                    ctx.strokeStyle = '#222';
                    ctx.strokeRect(tileX, tileY, tileSize, tileSize);
                }
            }
        }
    }

    // --- é—œéµåŠŸèƒ½ï¼šè²æ³¢ç…§æ˜ (Raycasting) ---
    // æ ¹æ“šéŸ³é‡(micLevel)æ±ºå®šç…§äº®å‰æ–¹å¹¾æ ¼
    // åªæœ‰ç•¶ç©å®¶æœ‰ç§»å‹•æ–¹å‘æ™‚æ‰ç…§äº®
    if ((player.dirX !== 0 || player.dirY !== 0) && micLevel > 0) {
        ctx.fillStyle = 'rgba(255, 255, 0, 0.4)'; // åŠé€æ˜é»ƒå…‰
        
        for (let i = 1; i <= micLevel; i++) {
            let checkX = player.x + (player.dirX * i);
            let checkY = player.y + (player.dirY * i);
            
            // å¦‚æœè¶…å‡ºåœ°åœ–æˆ–æ’ç‰†ï¼Œå…‰ç·šåœæ­¢
            if (checkX < 0 || checkX >= mapWidth || checkY < 0 || checkY >= mapHeight || map[checkY][checkX] === 0) {
                // ç…§äº®æœ€å¾Œé€™é¢ç‰†
                let px = checkX * tileSize + offsetX;
                let py = checkY * tileSize + offsetY;
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // æ’ç‰†é¡¯ç¤ºç´…è‰²
                ctx.fillRect(px, py, tileSize, tileSize);
                break; 
            }
            
            // ç…§äº®è·¯å¾‘
            let px = checkX * tileSize + offsetX;
            let py = checkY * tileSize + offsetY;
            ctx.fillRect(px, py, tileSize, tileSize);
        }
    }

    // ç¹ªè£½ç©å®¶
    let pScreenX = player.x * tileSize + offsetX;
    let pScreenY = player.y * tileSize + offsetY;
    ctx.fillStyle = '#0f0'; // ç¶ è‰²ç©å®¶
    ctx.fillRect(pScreenX, pScreenY, tileSize, tileSize);
    
    // ç¹ªè£½å°ç®­é ­æŒ‡ç¤ºæ–¹å‘
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(pScreenX + tileSize/2 + player.dirX*5, pScreenY + tileSize/2 + player.dirY*5, 2, 0, Math.PI*2);
    ctx.fill();

    // ç¹ªè£½çµ‚é»
    let gScreenX = goal.x * tileSize + offsetX;
    let gScreenY = goal.y * tileSize + offsetY;
    ctx.fillStyle = 'gold';
    ctx.font = '16px Arial';
    ctx.fillText('ğŸš©', gScreenX, gScreenY + 16);
}

function gameLoop() {
    updateMic();
    draw();
    requestAnimationFrame(gameLoop);
}

// å•Ÿå‹•æŒ‰éˆ•
document.getElementById('start-btn').addEventListener('click', () => {
    generateMap();
    initAudio();
});

</script>
</body>
</html>